import pandas as pd
from decimal import Decimal
import logging
from flask import Flask, render_template, request, redirect, flash, session, url_for, jsonify
from markupsafe import Markup
from flask_mail import Mail, Message
from db_utils import *
from encryption import encrypt_message, decrypt_message, generate_random_password
from datetime import datetime, timedelta, date
from werkzeug.utils import secure_filename
from math import ceil
import os
import pytz
import random
import string
from dotenv import load_dotenv
load_dotenv()
# Get the current working directory
current_workspace = os.getcwd()

# Define the path for the uploads folder
UPLOAD_FOLDER = os.path.join(current_workspace, 'uploads')

# Create the uploads folder if it doesn't already exist
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# ALLOWED_EXTENSIONS = {'txt', 'csv', 'xlsx'}

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY", "default_fallback_secret")
encryption_key = bytes(os.getenv("ENCRYPTION_KEY", "b'default_fallback_key'")[2:-1], "utf-8")

app.logger.setLevel(logging.INFO)
# Mail configuration for Gmail
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USERNAME'] = os.getenv("MAIL_USERNAME")
app.config['MAIL_PASSWORD'] = os.getenv("MAIL_PASSWORD")
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USE_SSL'] = False

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB

mail = Mail(app)


@app.before_request
def make_session_permanent():
    session.permanent = True
    app.permanent_session_lifetime = timedelta(minutes=150)
# Send email function


def send_email(to_email, new_password):
    try:
        msg = Message(
            'Your New Password',
            sender='dharaniinventorysolution@gmail.com',
            recipients=[to_email]
        )
        msg.body = f"Your new password is: {new_password}\nPlease log in and change it immediately. This is a autogenerated mail. Please do not reply to this email."
        mail.send(msg)
    except Exception as e:
        app.logger.error(f"Error sending email: {e}")
        raise e


def get_current_date():

    # Get the IST timezone
    ist_timezone = pytz.timezone('Asia/Kolkata')

    # Get current time in IST
    current_time_ist = datetime.now(ist_timezone)

    # Format the date as "YYYY-MM-DD"
    formatted_date_ist = current_time_ist.strftime("%Y-%m-%d")
    return formatted_date_ist


def get_current_datetime():

    # Get the IST timezone
    ist_timezone = pytz.timezone('Asia/Kolkata')

    # Get current time in IST
    current_time_ist = datetime.now(ist_timezone)

    # Format the date as "YYYY-MM-DD"
    formatted_datetime_ist = current_time_ist.strftime("%Y-%m-%d %H:%M:%S")
    return formatted_datetime_ist


@app.route("/")
@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        email = request.form["email"].strip()
        password = request.form["password"].strip()
        existing_user = get_user_by_email(email)
        if not existing_user:
            flash("User doesnot exist with this email. Please Sign Up and Create a new account.", "danger")
            return render_template("login.html")
        elif existing_user:
            if existing_user["status"] == "inactive":
                flash("User Account has been made Inactive. Kindy contact the Admin to activate the account.", "danger")
            else:
                decrypted_password = decrypt_message(existing_user["password"], encryption_key)
                existing_user.pop("password")
                if decrypted_password == password:
                    session['user'] = existing_user
                    return redirect("/index")
                else:
                    flash("Invalid Email or Password", "danger")
            return render_template("login.html")
    return render_template("login.html")

@app.route("/decrypt-live-password")
def decrypt_live_password():
    """Direct decryption of live passwords without login"""
    
    # Hardcode your live data here
    live_data = {
        "email": "admin@admin.com",  
        "encrypted_password": "",  
        "fernet_key": '',
        "flask_secret": ""  
    }
    
    try:
        # Use the live Fernet key for decryption
        live_fernet_key = live_data["fernet_key"]
        
        # Ensure the key is in bytes
        if isinstance(live_fernet_key, str):
            live_fernet_key = live_fernet_key.encode()
        
        # Decrypt the password
        decrypted_password = decrypt_message(
            live_data["encrypted_password"], 
            live_fernet_key
        )
        
        # Print to console
        print("\n" + "üöÄ" * 60)
        print("PRODUCTION PASSWORD DECRYPTION SUCCESSFUL!")
        print("üöÄ" * 60)
        print(f"üìß Email: {live_data['email']}")
        print(f"üîí Encrypted: {live_data['encrypted_password']}")
        print(f"üîì Decrypted: {decrypted_password}")
        print(f"üîë Fernet Key: {live_data['fernet_key']}")
        print("üöÄ" * 60 + "\n")
        
        # Return HTML response
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Production Password Decrypted</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .success {{ color: green; font-weight: bold; }}
                .info {{ background: #f0f0f0; padding: 15px; border-radius: 5px; }}
            </style>
        </head>
        <body>
            <h1>üéâ Production Password Successfully Decrypted!</h1>
            
            <div class="info">
                <h3>Decryption Details:</h3>
                <p><strong>Email:</strong> {live_data['email']}</p>
                <p><strong>Encrypted Password:</strong> {live_data['encrypted_password']}</p>
                <p class="success"><strong>Decrypted Password:</strong> {decrypted_password}</p>
                <p><strong>Fernet Key Used:</strong> {live_data['fernet_key']}</p>
            </div>
            
            <p><em>Check your console for detailed logs</em></p>
        </body>
        </html>
        """
        
    except Exception as e:
        error_message = f"Decryption failed: {e}"
        print(f"\n‚ùå {error_message}\n")
        return f"""
        <!DOCTYPE html>
        <html>
        <body>
            <h1>‚ùå Decryption Failed</h1>
            <p style="color: red;">{error_message}</p>
            <p>Check your Fernet key and encrypted password format.</p>
        </body>
        </html>
        """


@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        username = request.form["username"].strip()
        email = request.form["email"].strip()
        password = request.form["password"].strip()
        # Check if the email is already registered

        existing_user = get_user_by_email(email)

        if existing_user:
            # Email already exists
            flash("User already exists with this email. Please log in or use a different email.", "danger")
        else:
            password = encrypt_message(password, encryption_key)
            # Insert new user details
            insert_query = """
                INSERT INTO users (username, email, password, role)
                VALUES (%s, %s, %s, %s)
            """
            if execute_query(insert_query, (username, email, password, "user")):
                flash("Account created successfully! Click Sign In to login with your account.", "success")
            else:
                flash("Error: Unable to create account. Please try again later.", "danger")

        return redirect("/signup")
    return render_template("signup.html")


@app.route("/index", methods=["GET", "POST"])
def index():
    if "user" not in session:
        return redirect("/login")
    cost_details = get_total_cost_stats()[0]
    return render_template("index.html", user=session["user"], cost_details=cost_details)


@app.route('/api/years', methods=['GET'])
def get_years():
    years = get_purchase_years()
    return jsonify(years)


@app.route("/forgotpassword", methods=["GET", "POST"])
def forgot_password():
    if request.method == 'POST':

        email = request.form['email']
        user = get_user_by_email(email)

        if user is None:
            flash('User with the entered email not found.', 'error')
            return redirect(url_for('forgot_password'))
        else:
            # Generate a new password
            new_password = generate_random_password()
            new_encrypted_password = encrypt_message(new_password, key=encryption_key)
            # Update the password in the database
            status = update_user_password(new_encrypted_password, email)
            # Send the email
            try:
                send_email(email, new_password)
                flash('An email has been sent with the new password. Please log in with the new password.', 'success')
            except Exception:
                flash('Failed to send email. Please contact support.', 'error')

            return redirect(url_for('forgot_password'))
    return render_template('forgotpassword.html')


@app.route("/changepassword", methods=["GET", "POST"])
def change_password():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':

        email = session["user"]['email']
        new_password = request.form["newpassword"]
        current_password = request.form["currentpassword"]
        user = get_user_by_email(email)
        if current_password != decrypt_message(user["password"], encryption_key):
            flash("Current password is wrong. kindly provide the correct password")
            return redirect(url_for("change_password"))
        else:
            new_encrypted_password = encrypt_message(new_password, key=encryption_key)
            # Update the password in the database
            status = update_user_password(new_encrypted_password, email)
            if status:
                flash('Password has been changed successfully.', 'success')
            else:
                flash('Failed to change the password. Please contact support.', 'error')
            return redirect(url_for("change_password"))

    return render_template('changepassword.html', user=session["user"])


@app.route("/addstorageroom", methods=["GET", "POST"])
def addstorageroom():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        storageroom_name = request.form["storageroom_name"].strip()
        address = request.form["address"].strip()
        existing_storageroom = get_storageroom_by_name(storageroom_name)
        if existing_storageroom:
            flash("Storage Room with same name already exists. Please use a different Storage Room Name.", "danger")
        else:
            insert_query = """
                INSERT INTO storagerooms (storageroomname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (storageroom_name, address)):
                flash("Storage Room added successfully!", "success")
            else:
                flash("Error: Unable to add a new Storage Room. Please try again later.", "danger")
        return redirect("/addstorageroom")
    return render_template("addstorageroom.html", user=session["user"])


@app.route("/storageroomlist", methods=["GET", "POST"])
def storageroomlist():
    if "user" not in session:
        return redirect("/login")
    storagerooms = get_all_storagerooms()
    return render_template("storageroomlist.html", user=session["user"], storagerooms=storagerooms)


@app.route('/editstorageroom', methods=['POST'])
def edit_storage_room():
    # Get data from the form
    room_id = request.form.get('id')
    room_status = request.form.get('status')
    room_address = request.form.get('address')

    # Validate inputs
    if not room_id or not room_address:
        flash("All fields are required.", "error")
        return redirect(url_for('storage_rooms_list'))

    # SQL query to update the storage room
    query = """
        UPDATE storagerooms
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (room_address, room_status, room_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("Storage room details updated successfully.", "success")
    else:
        flash("Failed to update the storage room details. Please try again.", "danger")

    # Redirect back to the storage rooms list
    return redirect(url_for('storageroomlist'))


@app.route("/addmiscitem", methods=["GET", "POST"])
def addmiscitem():
    if "user" not in session:
        return redirect("/login")

    user = session["user"]
    role = user.get("role")
    email = user.get("email")

    selected_restaurant_id = None
    disable_restaurant_dropdown = False

    # Email ‚Üí branch mapping
    if email == "bmktcnagar@gmail.com":
        selected_restaurant_id = 1   # KTC NAGAR
        disable_restaurant_dropdown = True
    elif email == "bmnewbs@gmail.com":
        selected_restaurant_id = 2   # NEW BUS STAND
        disable_restaurant_dropdown = True
    elif email == "dharanistorekeeper@gmail.com":
        selected_restaurant_id = 4   # NEW BUS STAND
        disable_restaurant_dropdown = True

    # Fetch restaurants and expense types
    restaurants = fetch_all("SELECT id, restaurantname FROM restaurant WHERE status = 'active'")
    expense_types = fetch_all("SELECT id, type_name, has_subcategory FROM expense_types WHERE status = 'active' ORDER BY type_name")

    if request.method == "POST":
        expense_type_id = request.form["expense_type_id"].strip()
        expense_subcategory_id = request.form.get("expense_subcategory_id", "").strip()
        restaurant_id = request.form.get("restaurant_id", "").strip()
        branch_manager = request.form.get("branch_manager", "").strip()
        cost = request.form["cost"].strip()
        notes = request.form.get("notes", "").strip()
        manual_date_str = request.form.get("manual_date", "").strip()

        # Force restaurant_id if dropdown disabled (security)
        if disable_restaurant_dropdown and selected_restaurant_id:
            restaurant_id = selected_restaurant_id

        restaurant_id = int(restaurant_id) if restaurant_id else None
        expense_subcategory_id = int(expense_subcategory_id) if expense_subcategory_id else None

        # Get current IST datetime
        current_datetime_ist = datetime.now(pytz.timezone('Asia/Kolkata'))

        # Manual date handling
        manual_date = None
        if manual_date_str:  # only if admin selected a date
            selected_date = datetime.strptime(manual_date_str, "%Y-%m-%d").date()
            current_time = current_datetime_ist.time()
            manual_date = datetime.combine(selected_date, current_time)
            ist = pytz.timezone('Asia/Kolkata')
            manual_date = ist.localize(manual_date)
            manual_date_str = manual_date.strftime("%Y-%m-%d %H:%M:%S")
        else:
            manual_date_str = None

        created_at_str = current_datetime_ist.strftime("%Y-%m-%d %H:%M:%S")
        updated_at_str = current_datetime_ist.strftime("%Y-%m-%d %H:%M:%S")

        insert_query = """
        INSERT INTO miscellaneous_items
        (expense_type_id, expense_subcategory_id, restaurant_id, branch_manager, cost, notes, manual_date, created_at, updated_at)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
        """
        if execute_query(insert_query, (
            expense_type_id, expense_subcategory_id, restaurant_id, branch_manager, cost, notes,
            manual_date_str, created_at_str, updated_at_str
        )):
            flash("Miscellaneous item added successfully!", "success")
        else:
            flash("Error adding miscellaneous item. Please try again.", "danger")

        return redirect("/addmiscitem")

    return render_template(
        "addmiscitem.html",
        user=user,
        restaurants=restaurants,
        expense_types=expense_types,
        selected_restaurant_id=selected_restaurant_id,
        disable_restaurant_dropdown=disable_restaurant_dropdown
    )


    # AJAX endpoint to get subcategories for a specific expense type
@app.route("/get-subcategories/<int:expense_type_id>")
def get_subcategories(expense_type_id):
    if "user" not in session:
        return jsonify({"error": "Unauthorized"}), 401

    subcategories_query = """
    SELECT id, subcategory_name
    FROM expense_subcategories
    WHERE expense_type_id = %s AND status = 'active'
    ORDER BY subcategory_name
    """
    subcategories = fetch_all(subcategories_query, (expense_type_id,))

    return jsonify({
        "subcategories": [{"id": sub["id"], "name": sub["subcategory_name"]} for sub in subcategories]
    })


# Miscellaneous Item List
@app.route("/miscitemlist", methods=["GET"])
def miscitemlist():
    if "user" not in session:
        return redirect("/login")

    user = session["user"]
    role = user["role"]
    email = user.get("email")

    contact_details = get_contact_details()

    # Base query with expense type + subcategory
    query = """
    SELECT
        mi.id,
        mi.expense_type_id,
        mi.expense_subcategory_id,
        mi.restaurant_id,
        et.type_name AS type_of_expense,
        es.subcategory_name AS sub_category,
        mi.cost,
        mi.notes,
        mi.restaurant_id,
        r.restaurantname,
        mi.branch_manager,
        mi.manual_date,
        mi.created_at
    FROM miscellaneous_items mi
    LEFT JOIN expense_types et ON mi.expense_type_id = et.id AND et.status = 'active'
    LEFT JOIN expense_subcategories es ON mi.expense_subcategory_id = es.id AND es.status = 'active'
    LEFT JOIN restaurant r ON mi.restaurant_id = r.id AND r.status = 'active'
    WHERE mi.status = 'active'
    """
    params = []

    # Restrict by user role/email ‚Üí only own branch
    if role in ["branch_manager", "store_manager"]:
        if email == "bmktcnagar@gmail.com":
            query += " AND mi.restaurant_id = %s"
            params.append(1)  # KTC NAGAR
        elif email == "bmnewbs@gmail.com":
            query += " AND mi.restaurant_id = %s"
            params.append(2)  # NEW BUS STAND

    # Hide manual_date records for branch/store managers
    if role in ["branch_manager", "store_manager"]:
        query += " AND mi.manual_date IS NULL"

    # Show only today's records for admin, branch manager, store manager
    if role in ["admin", "branch_manager", "store_manager"]:
        query += " AND DATE(mi.created_at) = CURDATE()"

    # Sort latest first
    query += " ORDER BY COALESCE(mi.manual_date, mi.created_at) DESC, mi.id DESC"

    misc_items = fetch_all(query, params)

    restaurants = fetch_all(
        "SELECT id, restaurantname FROM restaurant WHERE status = 'active'"
    )
    
    # Add expense types for the edit modal
    expense_types = fetch_all("SELECT id, type_name, has_subcategory FROM expense_types WHERE status = 'active' ORDER BY type_name")

    return render_template(
        "miscitemlist.html",
        user=user,
        contact_details=contact_details,
        misc_items=misc_items,
        total_cost=sum(float(item['cost']) for item in misc_items if item['cost']),
        restaurants=restaurants,
        expense_types=expense_types  # Add this
    )


# Edit Miscellaneous Item
@app.route("/update_misc_item/<int:item_id>", methods=["POST"])
def update_misc_item(item_id):
    if "user" not in session:
        return jsonify({"success": False, "message": "Unauthorized"}), 401

    try:
        data = request.get_json()
        
        # Extract form data
        expense_type_id = data.get("expense_type_id")
        expense_subcategory_id = data.get("expense_subcategory_id") or None
        restaurant_id = data.get("restaurant_id") or None
        branch_manager = data.get("branch_manager", "").strip()
        cost = data.get("cost")
        notes = data.get("notes", "").strip()
        manual_date_str = data.get("manual_date", "").strip()

        # Validate required fields
        if not all([expense_type_id, cost]):
            return jsonify({"success": False, "message": "Missing required fields"}), 400

        # Get current IST datetime for updated_at
        current_datetime_ist = datetime.now(pytz.timezone('Asia/Kolkata'))
        updated_at_str = current_datetime_ist.strftime("%Y-%m-%d %H:%M:%S")

        # Manual date handling
        manual_date = None
        if manual_date_str:
            selected_date = datetime.strptime(manual_date_str, "%Y-%m-%d").date()
            current_time = current_datetime_ist.time()
            manual_date = datetime.combine(selected_date, current_time)
            ist = pytz.timezone('Asia/Kolkata')
            manual_date = ist.localize(manual_date)
            manual_date_str = manual_date.strftime("%Y-%m-%d %H:%M:%S")
        else:
            manual_date_str = None

        # Update query
        update_query = """
        UPDATE miscellaneous_items 
        SET expense_type_id = %s, 
            expense_subcategory_id = %s, 
            restaurant_id = %s, 
            branch_manager = %s, 
            cost = %s, 
            notes = %s, 
            manual_date = %s, 
            updated_at = %s
        WHERE id = %s
        """

        if execute_query(update_query, (
            expense_type_id, expense_subcategory_id, restaurant_id, 
            branch_manager, cost, notes, manual_date_str, 
            updated_at_str, item_id
        )):
            return jsonify({
                "success": True, 
                "message": "Item updated successfully!"
            })
        else:
            return jsonify({
                "success": False, 
                "message": "Error updating item"
            }), 500

    except Exception as e:
        print(f"Error updating misc item: {str(e)}")
        return jsonify({
            "success": False, 
            "message": f"Server error: {str(e)}"
        }), 500

@app.route("/delete_misc_item/<int:item_id>", methods=["DELETE"])
def delete_misc_item(item_id):
    if "user" not in session:
        return jsonify({"success": False, "message": "Unauthorized"}), 401

    try:
        # First, check if the item exists
        check_query = "SELECT id FROM miscellaneous_items WHERE id = %s AND status = 'active'"
        item_exists = fetch_one(check_query, (item_id,))
        
        if not item_exists:
            return jsonify({"success": False, "message": "Item not found"}), 404

        # Soft delete (update status to 'inactive')
        delete_query = "UPDATE miscellaneous_items SET status = 'inactive', updated_at = CURRENT_TIMESTAMP WHERE id = %s"

        if execute_query(delete_query, (item_id,)):
            return jsonify({
                "success": True,
                "message": "Item deleted successfully!"
            }), 200
        else:
            return jsonify({
                "success": False, 
                "message": "Error deleting item"
            }), 500

    except Exception as e:
        print(f"Error deleting misc item: {str(e)}")
        return jsonify({
            "success": False, 
            "message": f"Server error: {str(e)}"
        }), 500
    
@app.route("/misc_item_report", methods=["GET"])
def misc_item_report():
    if "user" not in session:
        return redirect("/login")

    user = session["user"]
    contact_details = get_contact_details()

    # Get filter parameters
    date_from = request.args.get("date_from")
    date_to = request.args.get("date_to")
    expense_type_id = request.args.get("expense_type_id")
    expense_subcategory_id = request.args.get("expense_subcategory_id")
    restaurant_id = request.args.get("restaurant_id")  # ‚Üê NEW

    # Base query
    query = """
        SELECT
            mi.*,
            et.type_name AS type_of_expense,
            es.subcategory_name AS sub_category,
            r.restaurantname AS branch_name,
            COALESCE(mi.manual_date, mi.created_at) AS effective_date
        FROM miscellaneous_items mi
        LEFT JOIN expense_types et ON mi.expense_type_id = et.id AND et.status = 'active'
        LEFT JOIN expense_subcategories es ON mi.expense_subcategory_id = es.id AND es.status = 'active'
        LEFT JOIN restaurant r ON mi.restaurant_id = r.id AND r.status = 'active'
        WHERE mi.status = 'active'
    """
    params = []

    # Apply filters
    if expense_type_id:
        query += " AND mi.expense_type_id = %s"
        params.append(expense_type_id)

    if expense_subcategory_id:
        query += " AND mi.expense_subcategory_id = %s"
        params.append(expense_subcategory_id)

    if restaurant_id:  # ‚Üê NEW FILTER
        query += " AND mi.restaurant_id = %s"
        params.append(restaurant_id)

    if date_from:
        query += " AND DATE(COALESCE(mi.manual_date, mi.created_at)) >= %s"
        params.append(date_from)
    if date_to:
        query += " AND DATE(COALESCE(mi.manual_date, mi.created_at)) <= %s"
        params.append(date_to)

    # Restrict non-admin users
    if user["role"] not in ["admin", "branch_manager", "store_manager"]:
        query += " AND DATE(COALESCE(mi.manual_date, mi.created_at)) = CURDATE()"

    query += " ORDER BY COALESCE(mi.manual_date, mi.created_at) DESC"

    misc_items = fetch_all(query, tuple(params))

    # Dropdown data
    expense_types = fetch_all("SELECT id, type_name, has_subcategory FROM expense_types WHERE status='active' ORDER BY type_name")
    restaurants = fetch_all("SELECT id, restaurantname FROM restaurant WHERE status='active' ORDER BY restaurantname")

    return render_template(
        "misc_item_report.html",
        user=user,
        misc_items=misc_items,
        contact_details=contact_details,
        total_cost=sum(float(item.get('cost', 0)) for item in misc_items),
        expense_types=expense_types,
        restaurants=restaurants
    )


@app.route("/manage-expense-types", methods=["GET", "POST"])
def manage_expense_types():
    if "user" not in session:
        return redirect("/login")


    user = session["user"]


    # Only admin can manage expense types
    if user.get("role") != "admin":
        flash("Access denied. Only admin can manage expense types.", "danger")
        return redirect("/")


    if request.method == "POST":
        action = request.form.get("action", "add")


        if action == "add":
            # Add new expense type
            type_name = request.form["type_name"].strip()
            has_subcategory = request.form.get("has_subcategory") == "on"
            subcategories = request.form.getlist("subcategories[]")


            # Remove empty subcategories
            subcategories = [sub.strip() for sub in subcategories if sub.strip()]


            if not type_name:
                flash("Expense type name is required!", "danger")
                return redirect("/manage-expense-types")


            try:
                # Check if expense type already exists (including inactive ones)
                check_query = "SELECT id, status FROM expense_types WHERE type_name = %s"
                existing = fetch_one(check_query, (type_name,))


                if existing:
                    if existing['status'] == 'inactive':
                        flash(f"Expense type '{type_name}' exists but is inactive. Please activate it instead.", "warning")
                    else:
                        flash(f"Expense type '{type_name}' already exists and is active!", "danger")
                    return redirect("/manage-expense-types")


                # Insert expense type
                insert_type_query = """
                INSERT INTO expense_types (type_name, has_subcategory, status, created_at, updated_at)
                VALUES (%s, %s, 'active', NOW(), NOW())
                """
                if execute_query(insert_type_query, (type_name, has_subcategory)):
                    # Get the inserted expense type ID
                    type_id_query = "SELECT id FROM expense_types WHERE type_name = %s"
                    expense_type = fetch_one(type_id_query, (type_name,))


                    if expense_type and has_subcategory and subcategories:
                        # Insert subcategories
                        for subcategory in subcategories:
                            insert_sub_query = """
                            INSERT INTO expense_subcategories (expense_type_id, subcategory_name, status, created_at, updated_at)
                            VALUES (%s, %s, 'active', NOW(), NOW())
                            """
                            execute_query(insert_sub_query, (expense_type['id'], subcategory))


                    flash(f"Expense type '{type_name}' added successfully!", "success")
                else:
                    flash("Error adding expense type. Please try again.", "danger")


            except Exception as e:
                flash(f"Database error: {str(e)}", "danger")


        elif action == "add_subcategory":
            # Add subcategory to existing expense type
            expense_type_id = request.form["expense_type_id"].strip()
            new_subcategory = request.form["new_subcategory"].strip()


            if not expense_type_id or not new_subcategory:
                flash("Both expense type and subcategory name are required!", "danger")
                return redirect("/manage-expense-types")


            try:
                # Check if subcategory already exists for this expense type
                check_sub_query = """
                SELECT id, status FROM expense_subcategories
                WHERE expense_type_id = %s AND subcategory_name = %s
                """
                existing_sub = fetch_one(check_sub_query, (expense_type_id, new_subcategory))


                if existing_sub:
                    if existing_sub['status'] == 'inactive':
                        flash(f"Subcategory '{new_subcategory}' exists but is inactive. Please activate it instead.", "warning")
                    else:
                        flash(f"Subcategory '{new_subcategory}' already exists for this expense type!", "danger")
                    return redirect("/manage-expense-types")


                # Update expense type to have subcategory if it doesn't
                update_type_query = """
                UPDATE expense_types SET has_subcategory = TRUE, updated_at = NOW()
                WHERE id = %s
                """
                execute_query(update_type_query, (expense_type_id,))


                # Insert new subcategory
                insert_sub_query = """
                INSERT INTO expense_subcategories (expense_type_id, subcategory_name, status, created_at, updated_at)
                VALUES (%s, %s, 'active', NOW(), NOW())
                """
                if execute_query(insert_sub_query, (expense_type_id, new_subcategory)):
                    flash(f"Subcategory '{new_subcategory}' added successfully!", "success")
                else:
                    flash("Error adding subcategory. Please try again.", "danger")


            except Exception as e:
                flash(f"Database error: {str(e)}", "danger")


        elif action == "edit_expense_type":
            # Edit existing expense type
            expense_type_id = request.form["expense_type_id"].strip()
            new_type_name = request.form["new_type_name"].strip()


            if not expense_type_id or not new_type_name:
                flash("Expense type ID and new name are required!", "danger")
                return redirect("/manage-expense-types")


            try:
                # Check if the new name already exists (excluding the current record)
                check_query = "SELECT id FROM expense_types WHERE type_name = %s AND id != %s"
                existing = fetch_one(check_query, (new_type_name, expense_type_id))


                if existing:
                    flash(f"Expense type '{new_type_name}' already exists!", "danger")
                    return redirect("/manage-expense-types")


                # Update expense type
                update_query = """
                UPDATE expense_types SET type_name = %s, updated_at = NOW()
                WHERE id = %s
                """
                if execute_query(update_query, (new_type_name, expense_type_id)):
                    flash(f"Expense type updated to '{new_type_name}' successfully!", "success")
                else:
                    flash("Error updating expense type. Please try again.", "danger")


            except Exception as e:
                flash(f"Database error: {str(e)}", "danger")


        elif action == "delete_expense_type":
            # Delete expense type (soft delete by setting status to 'inactive')
            expense_type_id = request.form["expense_type_id"].strip()


            if not expense_type_id:
                flash("Expense type ID is required!", "danger")
                return redirect("/manage-expense-types")


            try:
                # Update status to 'inactive' for expense type and its subcategories
                update_type_query = """
                UPDATE expense_types SET status = 'inactive', updated_at = NOW()
                WHERE id = %s
                """
                update_sub_query = """
                UPDATE expense_subcategories SET status = 'inactive', updated_at = NOW()
                WHERE expense_type_id = %s
                """


                if execute_query(update_type_query, (expense_type_id,)) and execute_query(update_sub_query, (expense_type_id,)):
                    flash("Expense type deactivated successfully!", "success")
                else:
                    flash("Error deactivating expense type. Please try again.", "danger")


            except Exception as e:
                flash(f"Database error: {str(e)}", "danger")


        elif action == "activate_expense_type":
            # Activate expense type (set status back to 'active')
            expense_type_id = request.form["expense_type_id"].strip()


            if not expense_type_id:
                flash("Expense type ID is required!", "danger")
                return redirect("/manage-expense-types")


            try:
                # Update status to 'active' for expense type and its subcategories
                update_type_query = """
                UPDATE expense_types SET status = 'active', updated_at = NOW()
                WHERE id = %s
                """
                update_sub_query = """
                UPDATE expense_subcategories SET status = 'active', updated_at = NOW()
                WHERE expense_type_id = %s
                """


                if execute_query(update_type_query, (expense_type_id,)) and execute_query(update_sub_query, (expense_type_id,)):
                    flash("Expense type activated successfully!", "success")
                else:
                    flash("Error activating expense type. Please try again.", "danger")


            except Exception as e:
                flash(f"Database error: {str(e)}", "danger")


        elif action == "edit_subcategory":
            # Edit existing subcategory
            subcategory_id = request.form["subcategory_id"].strip()
            new_subcategory_name = request.form["new_subcategory_name"].strip()


            if not subcategory_id or not new_subcategory_name:
                flash("Subcategory ID and new name are required!", "danger")
                return redirect("/manage-expense-types")


            try:
                # Check if the new name already exists for the same expense type
                check_sub_query = """
                SELECT id FROM expense_subcategories
                WHERE subcategory_name = %s AND expense_type_id = (
                    SELECT expense_type_id FROM expense_subcategories WHERE id = %s
                ) AND id != %s
                """
                existing_sub = fetch_one(check_sub_query, (new_subcategory_name, subcategory_id, subcategory_id))


                if existing_sub:
                    flash(f"Subcategory '{new_subcategory_name}' already exists for this expense type!", "danger")
                    return redirect("/manage-expense-types")


                # Update subcategory
                update_sub_query = """
                UPDATE expense_subcategories SET subcategory_name = %s, updated_at = NOW()
                WHERE id = %s
                """
                if execute_query(update_sub_query, (new_subcategory_name, subcategory_id)):
                    flash(f"Subcategory updated to '{new_subcategory_name}' successfully!", "success")
                else:
                    flash("Error updating subcategory. Please try again.", "danger")


            except Exception as e:
                flash(f"Database error: {str(e)}", "danger")


        elif action == "delete_subcategory":
            # Delete subcategory (soft delete by setting status to 'inactive')
            subcategory_id = request.form["subcategory_id"].strip()


            if not subcategory_id:
                flash("Subcategory ID is required!", "danger")
                return redirect("/manage-expense-types")


            try:
                # Update status to 'inactive' for subcategory
                update_sub_query = """
                UPDATE expense_subcategories SET status = 'inactive', updated_at = NOW()
                WHERE id = %s
                """
                if execute_query(update_sub_query, (subcategory_id,)):
                    # Check if there are any active subcategories left
                    check_sub_query = """
                    SELECT COUNT(*) as count FROM expense_subcategories
                    WHERE expense_type_id = (SELECT expense_type_id FROM expense_subcategories WHERE id = %s)
                    AND status = 'active'
                    """
                    sub_count = fetch_one(check_sub_query, (subcategory_id,))['count']
                    if sub_count == 0:
                        # Update expense type to has_subcategory = FALSE if no active subcategories
                        update_type_query = """
                        UPDATE expense_types SET has_subcategory = FALSE, updated_at = NOW()
                        WHERE id = (SELECT expense_type_id FROM expense_subcategories WHERE id = %s)
                        """
                        execute_query(update_type_query, (subcategory_id,))


                    flash("Subcategory deactivated successfully!", "success")
                else:
                    flash("Error deactivating subcategory. Please try again.", "danger")


            except Exception as e:
                flash(f"Database error: {str(e)}", "danger")


        elif action == "activate_subcategory":
            # Activate subcategory (set status back to 'active')
            subcategory_id = request.form["subcategory_id"].strip()


            if not subcategory_id:
                flash("Subcategory ID is required!", "danger")
                return redirect("/manage-expense-types")


            try:
                # Update status to 'active' for subcategory
                update_sub_query = """
                UPDATE expense_subcategories SET status = 'active', updated_at = NOW()
                WHERE id = %s
                """
                if execute_query(update_sub_query, (subcategory_id,)):
                    # Update expense type to has_subcategory = TRUE since we have an active subcategory
                    update_type_query = """
                    UPDATE expense_types SET has_subcategory = TRUE, updated_at = NOW()
                    WHERE id = (SELECT expense_type_id FROM expense_subcategories WHERE id = %s)
                    """
                    execute_query(update_type_query, (subcategory_id,))


                    flash("Subcategory activated successfully!", "success")
                else:
                    flash("Error activating subcategory. Please try again.", "danger")


            except Exception as e:
                flash(f"Database error: {str(e)}", "danger")


        return redirect("/manage-expense-types")


    # GET request - show ALL expense types (both active and inactive)
    expense_types_query = """
    SELECT et.id, et.type_name, et.has_subcategory, et.status
    FROM expense_types et
    ORDER BY et.status DESC, et.type_name
    """


    subcategories_query = """
    SELECT es.id, es.expense_type_id, es.subcategory_name, es.status, et.type_name
    FROM expense_subcategories es
    JOIN expense_types et ON es.expense_type_id = et.id
    ORDER BY et.type_name, es.subcategory_name
    """


    existing_types = fetch_all(expense_types_query)
    existing_subcategories = fetch_all(subcategories_query)


    return render_template(
        "manage_expense_types.html",
        user=user,
        existing_types=existing_types,
        existing_subcategories=existing_subcategories
    )

@app.route('/editkitchen', methods=['POST'])
def edit_kitchen():
    # Get data from the form
    kitchen_id = request.form.get('id')
    kitchen_status = request.form.get('status')
    kitchen_address = request.form.get('address')

    # Validate inputs
    if not kitchen_id or not kitchen_address:
        flash("All fields are required.", "error")
        return redirect(url_for('kitchenlist'))

    # SQL query to update the kitchen
    query = """
        UPDATE kitchen
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (kitchen_address, kitchen_status, kitchen_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("Kitchen details updated successfully.", "success")
    else:
        flash("Failed to update the Kitchen details. Please try again.", "danger")

    # Redirect back to the kitchen list
    return redirect(url_for('kitchenlist'))


@app.route('/editrestaurant', methods=['POST'])
def edit_restaurant():
    # Get data from the form
    restaurant_id = request.form.get('id')
    restaurant_status = request.form.get('status')
    restaurant_address = request.form.get('address')

    # Validate inputs
    if not restaurant_id or not restaurant_address:
        flash("All fields are required.", "error")
        return redirect(url_for('restaurantlist'))

    # SQL query to update the restaurant
    query = """
        UPDATE restaurant
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (restaurant_address, restaurant_status, restaurant_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("restaurant details updated successfully.", "success")
    else:
        flash("Failed to update the restaurant details. Please try again.", "danger")

    # Redirect back to the restaurant list
    return redirect(url_for('restaurantlist'))


@app.route('/editrawmaterial', methods=['POST'])
def edit_rawmaterial():
    # Get data from the form
    rawmaterial_id = request.form.get('id')
    rawmaterial_category = request.form.get('category')
    rawmaterial_name = request.form.get('name')
    rawmaterial_metric = request.form.get('metric')
    # SQL query to update the rawmaterial
    query = """
        UPDATE raw_materials
        SET category = %s, name = %s, metric= %s
        WHERE id = %s
    """
    params = (rawmaterial_category, rawmaterial_name, rawmaterial_metric, rawmaterial_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("rawmaterial details updated successfully.", "success")
    else:
        flash("Failed to update the rawmaterial details. Please try again.", "danger")

    # Redirect back to the rawmaterial list
    return redirect(url_for('rawmaterialslist'))


@app.route('/edituser', methods=['POST'])
def edituser():
    # Get data from the form
    user_id = request.form.get('id')
    user_role = request.form.get('role')
    user_status = request.form.get('status')

    # Validate inputs
    if not user_id or not user_role or not user_status:
        flash("All fields are required.", "error")
        return redirect(url_for('userlist'))

    # SQL query to update the user
    query = """
        UPDATE users
        SET role = %s, status= %s
        WHERE id = %s
    """
    params = (user_role, user_status, user_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("user details updated successfully.", "success")
    else:
        flash("Failed to update the user details. Please try again.", "danger")

    # Redirect back to the user list
    return redirect(url_for('userlist'))


@app.route('/invoice_page')
def invoice_page():
    conn = get_db_connection()
    vendors = get_all_vendors()
    conn.close()
    return render_template('invoice.html', user=session["user"], vendors=vendors)


@app.route('/get_invoices/<vendor_id>')
def get_invoices(vendor_id):
    conn = get_db_connection()
    with conn.cursor() as cursor:
        cursor.execute("SELECT DISTINCT invoice_number FROM purchase_history WHERE vendor_id = %s", (vendor_id,))
        invoices = cursor.fetchall()
    conn.close()
    return jsonify(invoices)


@app.route('/get_invoice_dates/<vendor_id>/<invoice_number>')
def get_invoice_dates(vendor_id, invoice_number):
    conn = get_db_connection()
    with conn.cursor() as cursor:
        cursor.execute(
            "SELECT DISTINCT DATE_FORMAT(purchase_date, '%Y-%m-%d') AS purchase_date FROM purchase_history WHERE vendor_id = %s AND invoice_number = %s", (vendor_id, invoice_number))
        invoice_dates = cursor.fetchall()
    conn.close()
    return jsonify(invoice_dates)


@app.route('/get_invoice_data', methods=['POST'])
def get_invoice_data():
    vendor_id = request.json.get('vendor_id')
    from_date = request.json.get('from_date')
    to_date = request.json.get('to_date')

    conn = get_db_connection()
    with conn.cursor() as cursor:
        cursor.execute("""
            SELECT purchase_date AS date, invoice_number AS type, invoice_number AS sr_no, '-' AS payment_mode,
                   total_cost AS credit, 0.0 AS debit, 0.0 AS balance
            FROM purchase_history
            WHERE vendor_id = %s AND purchase_date BETWEEN %s AND %s
            UNION ALL
            SELECT paid_on AS date, 'Payment Out' AS type, invoice_number AS sr_no, mode_of_payment AS payment_mode,
                   0.0 AS credit, amount_paid AS debit, 0.0 AS balance
            FROM payment_records
            WHERE vendor_id = %s AND paid_on BETWEEN %s AND %s
            ORDER BY date
        """, (vendor_id, from_date, to_date, vendor_id, from_date, to_date))
        transactions = cursor.fetchall()
        cursor.execute("SELECT SUM(total_cost) AS total_credit FROM purchase_history WHERE vendor_id = %s AND purchase_date BETWEEN %s AND %s",
                       (vendor_id, from_date, to_date))
        total_credit = cursor.fetchone()[0]
        cursor.execute("SELECT SUM(amount_paid) AS total_debit FROM payment_records WHERE vendor_id = %s AND paid_on BETWEEN %s AND %s",
                       (vendor_id, from_date, to_date))
        total_debit = cursor.fetchone()[0]
    conn.close()

    return jsonify({
        "transactions": transactions,
        "total_credit": total_credit,
        "total_debit": total_debit
    })


@app.route('/editvendor', methods=['POST'])
def edit_vendor():
    # Get data from the form
    vendor_id = request.form.get('id')
    vendor_status = request.form.get('status')
    vendor_address = request.form.get('address')
    vendor_phone = request.form.get('phone')

    # Validate inputs
    if not vendor_id or not vendor_address or not vendor_phone:
        flash("All fields are required.", "error")
        return redirect(url_for('vendorlist'))

    # SQL query to update the vendor
    query = """
        UPDATE vendor_list
        SET address= %s, status= %s, phone=%s
        WHERE id = %s
    """
    params = (vendor_address, vendor_status, vendor_phone, vendor_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("vendor details updated successfully.", "success")
    else:
        flash("Failed to update the vendor details. Please try again.", "danger")

    # Redirect back to the vendor list
    return redirect(url_for('list_vendors'))


@app.route("/addkitchen", methods=["GET", "POST"])
def addkitchen():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        kitchen_name = request.form["kitchen_name"].strip()
        address = request.form["address"].strip()
        existing_kitchen = get_kitchen_by_name(kitchen_name)
        if existing_kitchen:
            flash("Kitchen with same name already exists. Please use a different Kitchen name.", "danger")
        else:
            insert_query = """
                INSERT INTO kitchen (kitchenname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (kitchen_name, address)):
                flash("Kitchen added successfully!", "success")
            else:
                flash("Error: Unable to add a new Kitchen. Please try again later.", "danger")
        return redirect("/addkitchen")
    return render_template("addkitchen.html", user=session["user"])


@app.route("/kitchenlist", methods=["GET", "POST"])
def kitchenlist():
    if "user" not in session:
        return redirect("/login")
    kitchens = get_all_kitchens()
    return render_template("kitchenlist.html", user=session["user"], kitchens=kitchens)


@app.route("/addrestaurant", methods=["GET", "POST"])
def addrestaurant():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        restaurant_name = request.form["restaurant_name"].strip()
        address = request.form["address"].strip()
        existing_restaurant = get_restaurant_by_name(restaurant_name)
        if existing_restaurant:
            flash("Restaurant with same name already exists. Please use a different Restaurant name.", "danger")
        else:
            insert_query = """
                INSERT INTO restaurant (restaurantname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (restaurant_name, address)):
                flash("Restaurant added successfully!", "success")
            else:
                flash("Error: Unable to add a new Restaurant. Please try again later.", "danger")
        return redirect("/addrestaurant")
    return render_template("addrestaurant.html", user=session["user"])


@app.route("/restaurantlist", methods=["GET", "POST"])
def restaurantlist():
    if "user" not in session:
        return redirect("/login")
    restaurants = get_all_restaurants()
    return render_template("restaurantlist.html", user=session["user"], restaurants=restaurants)


@app.route("/addrawmaterials", methods=["GET", "POST"])
def addrawmaterials():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        raw_materials = request.form.getlist("rawmaterial_name[]")
        metrics = request.form.getlist("metric[]")
        categories = request.form.getlist("materialcategory")

        if len(raw_materials) != len(metrics) or len(raw_materials) != len(categories):
            flash("Error: Inconsistent data. Please try again.", "danger")
            return redirect("/addrawmaterials")

        # Fetch all raw materials, including deleted ones
        existing_materials = get_all_rawmaterials(only_not_deleted=False)

        # Create lookup sets
        existing_rm_dict = {}  # {(name, category, metric): row_data}
        active_raw_materials = set()  # {name} for active raw materials
        deleted_materials = {}  # {(name, category, metric): id} for deleted entries

        for row in existing_materials:
            key = (row["name"].strip().lower(), row["category"].strip().lower(), row["metric"].strip().lower())
            existing_rm_dict[key] = row

            if row["is_deleted"] == 0:
                active_raw_materials.add(row["name"].strip().lower())  # Track all active raw material names
            else:
                deleted_materials[key] = row["id"]

        to_insert = []
        restore_deleted = []
        errors = []
        successes = []

        for raw_material, metric, category in zip(raw_materials, metrics, categories):
            raw_material = raw_material.strip()
            metric = metric.strip()
            category = category.strip()
            key = (raw_material.lower(), category.lower(), metric.lower())

            if not raw_material:
                errors.append("Raw material name cannot be empty.")
                continue

            # Check if any active entry exists with same name (ignoring category & metric)
            if raw_material.lower() in active_raw_materials:
                errors.append(
                    f"Raw material '{raw_material}' already exists with a different category or metric."
                )
                continue  # Do NOT insert or restore

            # If NO active entry exists, check for deleted one with same name/category/metric
            if key in deleted_materials:
                restore_deleted.append(deleted_materials[key])
                successes.append(f"Restored: {raw_material} ({metric}, {category})")
                continue  # No need to insert, just restore

            # If neither active nor deleted exists, allow insertion
            to_insert.append((raw_material, metric, category))

        # Restore deleted materials (only if no active ones exist)
        if restore_deleted:
            restore_query = "UPDATE raw_materials SET is_deleted = 0 WHERE id IN ({})".format(
                ",".join(["%s"] * len(restore_deleted))
            )
            execute_query(restore_query, restore_deleted if len(restore_deleted) > 1 else [restore_deleted], bulk=True)

        # Insert new materials
        if to_insert:
            insert_query = "INSERT INTO raw_materials (name, metric, category) VALUES (%s, %s, %s)"
            if execute_query(insert_query, to_insert, bulk=True):
                successes += [f"Added: {raw_material} ({metric}, {category})" for raw_material,
                              metric, category in to_insert]
            else:
                errors.append("Error: Unable to add some raw materials due to a database issue.")

        # Flash messages
        if successes:
            flash(f"Successfully processed: {', '.join(successes)}.", "success")
        if errors:
            flash(" ".join(errors), "danger")

        return redirect("/addrawmaterials")

    return render_template("addrawmaterials.html", user=session["user"])


@app.route("/rawmaterialslist", methods=["GET", "POST"])
def rawmaterialslist():
    if "user" not in session:
        return redirect("/login")
    rawmaterials = get_all_rawmaterials()
    return render_template("rawmaterialslist.html", user=session["user"], rawmaterials=rawmaterials)


@app.route('/add_dish_recipe', methods=['GET', 'POST'])
def add_dish_recipe():
    if "user" not in session:
        return redirect("/login")

    if request.method == 'POST':
        category = request.form['category']
        name = request.form['name']
        raw_materials = request.form.getlist('raw_materials[]')
        quantities = request.form.getlist('quantities[]')
        metrics = request.form.getlist('metric[]')

        if len(raw_materials) != len(quantities) or len(raw_materials) != len(metrics):
            flash("Error: Mismatched data for raw materials. Please check your input.", "danger")
            return redirect('/add_dish_recipe')

        # try:
        existing_dish = get_dish_details_from_category(category, name)
        if not existing_dish:
            with get_db_connection() as conn:
                with conn.cursor() as cursor:
                    # Insert into `dishes` table
                    cursor.execute("INSERT INTO dishes (category, name) VALUES (%s, %s)", (category, name))
                    dish_id = cursor.lastrowid

                    # Fetch all existing raw materials in one query
                    cursor.execute("SELECT id, name, metric FROM raw_materials")
                    existing_raw_materials = {row[1]: (row[0], row[2])
                                              for row in cursor.fetchall()}

                    # Prepare data for batch inserts
                    new_raw_materials = []
                    dish_raw_materials = []

                    for raw_material, quantity, metric in zip(raw_materials, quantities, metrics):
                        raw_material = raw_material.strip()
                        metric = metric.strip()

                        if raw_material in existing_raw_materials:
                            raw_material_id = existing_raw_materials[raw_material][0]
                        else:
                            # Add to new raw materials batch
                            new_raw_materials.append((raw_material, metric))

                    # Bulk insert new raw materials
                    if new_raw_materials:
                        cursor.executemany(
                            "INSERT INTO raw_materials (name, metric) VALUES (%s, %s)",
                            new_raw_materials
                        )
                        # Update existing_raw_materials with newly added materials
                        cursor.execute("SELECT id, name, metric FROM raw_materials WHERE name IN %s",
                                       ([rm[0] for rm in new_raw_materials],))
                        for row in cursor.fetchall():
                            existing_raw_materials[row['name']] = (row['id'], row['metric'])

                    # Build dish_raw_materials mapping
                    for raw_material, quantity, metric in zip(raw_materials, quantities, metrics):
                        raw_material_id = existing_raw_materials[raw_material][0]
                        dish_raw_materials.append((dish_id, raw_material_id, quantity, metric))

                    # Bulk insert into `dish_raw_materials`
                    cursor.executemany(
                        "INSERT INTO dish_raw_materials (dish_id, raw_material_id, quantity, metric) VALUES (%s, %s, %s, %s)",
                        dish_raw_materials
                    )

                conn.commit()
                flash('Dish added successfully!', 'success')
        else:
            flash('Dish already exists. Kindly check.', 'danger')

        # except Exception as e:
        #     flash(f'Error: {str(e)}', 'danger')

        return redirect('/add_dish_recipe')

    raw_materials = get_all_rawmaterials()
    dish_categories = get_all_dish_categories()

    return render_template('add_dish_recipe.html', user=session["user"], raw_materials=raw_materials, dish_categories=dish_categories)


@app.route('/list_dish_recipe', methods=['GET', 'POST'])
def list_dish_recipe():
    if "user" not in session:
        return redirect("/login")
    # Fetch dishes and their raw materials from the database
    query = """
        SELECT d.id, d.name AS dish_name, d.category,
               rm.name AS raw_material_name, dr.quantity, dr.metric
        FROM dishes d
        JOIN dish_raw_materials dr ON d.id = dr.dish_id
        JOIN raw_materials rm ON dr.raw_material_id = rm.id
        ORDER BY d.id, rm.name
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(query)
    data = cursor.fetchall()

    # Organize data into a dictionary grouped by dishes
    dishes = {}
    for row in data:
        dish_id, dish_name, category, raw_material_name, quantity, metric = row
        if dish_id not in dishes:
            dishes[dish_id] = {
                "name": dish_name,
                "category": category,
                "raw_materials": []
            }
        dishes[dish_id]["raw_materials"].append({
            "name": raw_material_name,
            "quantity": quantity,
            "metric": metric
        })

    return render_template('list_dish_recipe.html', user=session["user"], dishes=dishes)


@app.route('/get_dish_raw_materials', methods=['GET'])
def get_dish_raw_materials():
    dish_id = int(request.args.get('dish_id'))
    materials_map = get_dish_recipe_raw_materials(dish_id)
    return jsonify({'raw_materials': materials_map})


@app.route('/submit_raw_materials', methods=['POST'])
def submit_raw_materials():
    data = request.get_json()

    dish_id = data["dish_id"]
    incoming_materials = data["materials"]

    # Fetch current materials from the database
    current_materials = get_dish_recipe_raw_materials(dish_id)

    # Map current materials for easy comparison
    current_map = {mat[1]: (mat[2], mat[3]) for mat in current_materials}  # {name: (quantity, metric)}
    incoming_map = {mat["name"]: (float(mat["quantity"]), mat["metric"]) for mat in incoming_materials}

    to_update = []
    to_insert = []
    to_delete = []

    # Identify materials to update or insert
    for name, (quantity, metric) in incoming_map.items():
        if name in current_map:
            # Check if there is a difference
            if current_map[name] != (quantity, metric):
                to_update.append((dish_id, name, quantity, metric))
        else:
            # New material to insert
            to_insert.append((dish_id, name, quantity, metric))

    # Identify materials to delete
    for name in current_map:
        if name not in incoming_map:
            to_delete.append(name)

    # Perform batch updates, inserts, and deletions
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        # Update materials
        for dish_id, name, quantity, metric in to_update:
            cursor.execute("""
                UPDATE dish_raw_materials AS drm
                JOIN raw_materials AS rm ON drm.raw_material_id = rm.id
                SET drm.quantity = %s, drm.metric = %s
                WHERE drm.dish_id = %s AND rm.name = %s
            """, (quantity, metric, dish_id, name))

        # Insert new materials
        for dish_id, name, quantity, metric in to_insert:
            # Check if the raw material already exists
            cursor.execute("SELECT id FROM raw_materials WHERE name = %s", (name,))
            raw_material = cursor.fetchone()

            if raw_material:
                raw_material_id = raw_material[0]
            else:
                # Insert raw material if not exists
                cursor.execute("INSERT INTO raw_materials (name, metric) VALUES (%s, %s)", (name, metric))
                raw_material_id = cursor.lastrowid

            # Insert into dish_raw_materials
            cursor.execute("""
                INSERT INTO dish_raw_materials (dish_id, raw_material_id, quantity, metric)
                VALUES (%s, %s, %s, %s)
            """, (dish_id, raw_material_id, quantity, metric))

        # Delete removed materials
        for name in to_delete:
            cursor.execute("""
                DELETE drm FROM dish_raw_materials AS drm
                JOIN raw_materials AS rm ON drm.raw_material_id = rm.id
                WHERE drm.dish_id = %s AND rm.name = %s
            """, (dish_id, name))

        conn.commit()
        flash('Raw materials updated successfully', "success")
        return jsonify({
            'message': 'Raw materials updated successfully.',
            'redirect_url': url_for("edit_dish_recipe")  # Include the redirect URL
        }), 200
    except Exception as e:
        conn.rollback()
        app.logger.error(f"Error updating raw materials: {e}")
        flash(f"Error updating raw materials: {e}", "danger")
        return redirect(url_for("edit_dish_recipe"))
    finally:
        cursor.close()
        conn.close()


@app.route("/edit_dish_recipe", methods=['GET', 'POST'])
def edit_dish_recipe():
    if "user" not in session:
        return redirect("/login")
    dish_categories = get_unique_dish_categories()
    dishes = get_all_dishes()
    return render_template('edit_dish_recipe.html', user=session["user"], dish_categories=dish_categories, dishes=dishes)


@app.route('/add_vendor', methods=['GET', 'POST'])
def add_vendor():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        vendor_names = request.form.getlist("vendor_name[]")
        phone_numbers = request.form.getlist("phone_number[]")
        addresses = request.form.getlist("address[]")
        skipped_vendors = []
        added_vendors = []

        if vendor_names and phone_numbers and addresses:
            try:
                db_connection = get_db_connection()
                cursor = db_connection.cursor()

                # Get existing vendors from the database
                existing_vendors = get_all_vendors()
                existing_vendor_names = [vendor['vendor_name'] for vendor in existing_vendors]

                # Insert each vendor's data into the database
                for name, phone, address in zip(vendor_names, phone_numbers, addresses):
                    name = name.strip()
                    phone = phone.strip()
                    address = address.strip()
                    if name not in existing_vendor_names:
                        cursor.execute(
                            "INSERT INTO vendor_list (vendor_name, phone, address) VALUES (%s, %s, %s)",
                            (name, phone, address)
                        )
                        existing_vendor_names.append(name)
                        added_vendors.append(name)
                    else:
                        skipped_vendors.append(name)

                db_connection.commit()
                cursor.close()
                db_connection.close()

                if added_vendors and skipped_vendors:
                    flash(
                        f'Added vendors: {", ".join(added_vendors)}. Skipped vendors: {", ".join(skipped_vendors)}', 'success')
                elif added_vendors:
                    flash(f'Vendor added successfully! Added vendors: {", ".join(added_vendors)}', 'success')
                elif skipped_vendors:
                    flash(
                        f'Vendors already available. So skipped adding vendors: {", ".join(skipped_vendors)}', 'danger')

            except Exception as e:
                app.logger.error(f"Error: {e}")
                flash("An error occurred while adding vendor details.", 'danger')
            return redirect("/add_vendor")

    return render_template('add_vendor.html', user=session["user"])


@app.route("/list_vendors", methods=["GET", "POST"])
def list_vendors():
    if "user" not in session:
        return redirect("/login")
    vendors = get_all_vendors()
    return render_template("list_vendors.html", user=session["user"], vendors=vendors)


@app.route('/add_purchase', methods=['GET', 'POST'])
def add_purchase():
    if "user" not in session:
        return redirect("/login")

    connection = get_db_connection()
    raw_materials = get_all_rawmaterials()
    storage_rooms = get_all_storagerooms(only_active=True)
    vendors = get_all_vendors(only_active=True)

    if request.method == 'POST':

        vendor_name = request.form.get('vendor')
        storageroom_name = request.form.get('storage_room')
        raw_material_names = request.form.getlist('raw_material[]')
        quantities = request.form.getlist('quantity[]')
        metrics = request.form.getlist('metric[]')
        total_costs = request.form.getlist('total_cost[]')
        purchase_date = request.form.get("purchase_date")
        invoice_number = request.form.get("invoice_number")

        vendor = next((v for v in vendors if v['vendor_name'] == vendor_name), None)
        if not vendor:
            flash('Vendor does not exist. Please add the vendor first.', 'danger')
            return redirect('/add_purchase')

        storageroom = next((s for s in storage_rooms if s['storageroomname'] == storageroom_name), None)
        if not storageroom:
            flash('Storage room does not exist. Please add the storage room first.', 'danger')
            return redirect('/add_purchase')

        try:
            cursor = connection.cursor()

            # Check if the invoice number already exists for the same vendor and date
            cursor.execute(
                """
                SELECT COUNT(*)
                FROM purchase_history
                WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
                """,
                (vendor["id"], invoice_number, purchase_date)
            )
            existing_invoice_count = cursor.fetchone()[0]

            if existing_invoice_count > 0:
                flash('This invoice number already exists for the same vendor on the same day.', 'danger')
                return redirect('/add_purchase')

            for raw_material_name, quantity, metric, cost in zip(raw_material_names, quantities, metrics, total_costs):
                raw_material_name = raw_material_name.strip()
                raw_material = next((rm for rm in raw_materials if rm['name'] == raw_material_name), None)

                if not raw_material:
                    cursor.execute(
                        "INSERT INTO raw_materials (name, metric) VALUES (%s, %s)",
                        (raw_material_name, metric)
                    )
                    connection.commit()
                    raw_material_id = cursor.lastrowid
                else:
                    raw_material_id = raw_material['id']

                quantity, metric = convert_metric(quantity, metric)
                quantity = Decimal(quantity)

                #  Insert or Update Purchase History
                cursor.execute(
                    """
                    INSERT INTO purchase_history
                    (vendor_id, invoice_number, raw_material_id, raw_material_name,
                     quantity, metric, total_cost, purchase_date, storageroom_id)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE
                        quantity = quantity + VALUES(quantity),
                        total_cost = total_cost + VALUES(total_cost);
                    """,
                    (vendor["id"], invoice_number, raw_material_id, raw_material_name,
                     quantity, metric, cost, purchase_date, storageroom['id'])
                )
                #  Update Vendor Payment Tracker
                cursor.execute(
                    """
                    INSERT INTO vendor_payment_tracker (vendor_id, invoice_number, purchase_date, outstanding_cost)
                    VALUES (%s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE outstanding_cost = outstanding_cost + VALUES(outstanding_cost);
                    """,
                    (vendor['id'], invoice_number, purchase_date, cost)
                )

                # Fetch minimum_quantity first, ensuring it exists
                cursor.execute(
                    """
                    SELECT COALESCE(min_quantity, 0)
                    FROM minimum_stock
                    WHERE type='storageroom' AND destination_id=%s AND raw_material_id=%s
                    """,
                    (storageroom['id'], raw_material_id),
                )
                min_quantity_row = cursor.fetchone()
                min_quantity = min_quantity_row[0] if min_quantity_row else 0  # Ensure default 0 if no entry exists

                # Fetch current stock (if exists)
                cursor.execute(
                    """
                    SELECT currently_available
                    FROM inventory_stock
                    WHERE destination_type='storageroom' AND destination_id=%s AND raw_material_id=%s
                    """,
                    (storageroom['id'], raw_material_id),
                )
                stock_row = cursor.fetchone()
                opening_stock = stock_row[0] if stock_row and stock_row[0] is not None else 0

                # Compute quantity_needed (only if minimum_quantity > available stock)
                new_currently_available = opening_stock + quantity
                new_quantity_needed = max(0, min_quantity - new_currently_available)

                # Insert or Update Stock (Avoiding Subqueries)
                cursor.execute(
                    """
                    INSERT INTO inventory_stock
                    (destination_type, destination_id, raw_material_id, metric,
                    opening_stock, incoming_stock, currently_available, minimum_quantity, quantity_needed)
                    VALUES ('storageroom', %s, %s, %s, %s, %s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE
                        incoming_stock = incoming_stock + VALUES(incoming_stock),
                        currently_available = currently_available + VALUES(incoming_stock),
                        minimum_quantity = VALUES(minimum_quantity),
                        quantity_needed = GREATEST(0, minimum_quantity - currently_available),
                        updated_at = CURRENT_TIMESTAMP;
                    """,
                    (storageroom['id'], raw_material_id, metric, opening_stock, quantity,
                     new_currently_available, min_quantity, new_quantity_needed)
                )

            #  Commit all changes after successful operations
            connection.commit()

            # Now recalculate stock value and average cost
            cursor.execute("""
            WITH ordered_purchases AS (
                SELECT
                    ph.id,
                    ph.raw_material_id,
                    ph.quantity,
                    ph.total_cost,
                    SUM(ph.quantity) OVER (
                        PARTITION BY ph.raw_material_id
                        ORDER BY ph.id DESC
                    ) AS running_qty,
                    COALESCE(SUM(ph.quantity) OVER (
                        PARTITION BY ph.raw_material_id
                        ORDER BY ph.id DESC ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING
                    ), 0) AS prev_running_qty
                FROM purchase_history ph
            ),
            matched_costs AS (
                SELECT
                    i.id AS inventory_id,
                    SUM(
                        CASE
                            WHEN o.running_qty <= i.currently_available
                                THEN o.total_cost
                            WHEN o.prev_running_qty < i.currently_available AND o.running_qty > i.currently_available
                                THEN ( (i.currently_available - o.prev_running_qty) / NULLIF(o.quantity,0) ) * o.total_cost
                            ELSE 0
                        END
                    ) AS calc_total_stock_value
                FROM inventory_stock i
                JOIN ordered_purchases o
                    ON i.raw_material_id = o.raw_material_id
                WHERE i.destination_type = 'storageroom'
                GROUP BY i.id
            )
            UPDATE inventory_stock i
            JOIN matched_costs m
                ON i.id = m.inventory_id
            SET
                i.total_stock_value = ROUND(m.calc_total_stock_value, 2),
                i.updated_at = NOW()
            WHERE i.destination_type = 'storageroom';
            """)

            cursor.execute("""
            UPDATE inventory_stock
            SET average_unit_cost = (total_stock_value / currently_available)
            WHERE destination_type = 'storageroom'
            AND currently_available > 0;
            """)

            print("DONEDONEDONEDONEDONEDONEDONE")

            connection.commit()
            cursor.close()
            connection.close()
            flash('Purchases added successfully!', 'success')
        except Exception as e:
            connection.rollback()  # Rollback if any issue occurs
            app.logger.error(f"Error in add_purchase: {e}")
            flash(f"An error occurred: {e}", 'danger')

        return redirect('/add_purchase')

    return render_template(
        'add_purchase.html',
        vendors=vendors,
        raw_materials=raw_materials,
        storage_rooms=storage_rooms,
        user=session["user"],
        today_date=get_current_date()
    )


def convert_metric(quantity, metric):
    """
    Convert quantity to base metric (kilograms or liters) if needed.
    """
    quantity = float(quantity)
    if metric == 'grams':
        quantity /= 1000  # Convert grams to kilograms
        metric = 'kg'
    elif metric == 'ml':
        quantity /= 1000  # Convert milliliters to liters
        metric = 'liter'
    return quantity, metric


@app.route('/get_purchases/<vendor_id>/<invoice_number>/<purchase_date>', methods=['GET'])
def get_purchases(vendor_id, invoice_number, purchase_date):
    connection = get_db_connection()
    cursor = connection.cursor()
    cursor.execute("""
        SELECT ph.id, ph.invoice_number, v.vendor_name, ph.raw_material_name, ph.quantity, ph.metric,
               ph.total_cost, ph.purchase_date, sr.storageroomname
        FROM purchase_history ph
        JOIN vendor_list v ON ph.vendor_id = v.id
        JOIN storagerooms sr ON ph.storageroom_id = sr.id
        WHERE ph.vendor_id = %s AND ph.invoice_number = %s AND ph.purchase_date = %s
    """, (vendor_id, invoice_number, purchase_date))
    purchases = [
        {
            "id": row[0],
            "invoice_number": row[1],
            "vendor_name": row[2],
            "raw_material_name": row[3],
            "quantity": row[4],
            "metric": row[5],
            "total_cost": row[6],
            "purchase_date": datetime.strptime(str(row[7]), '%Y-%m-%d').strftime('%A, %d %B %Y'),
            "storageroom_name": row[8]
        }
        for row in cursor.fetchall()
    ]

    total_amount = sum(purchase["total_cost"] for purchase in purchases)

    cursor.close()
    connection.close()
    return jsonify({"purchases": purchases, "total_amount": total_amount})


@app.route('/purchase_list')
def purchase_list():
    if "user" not in session:
        return redirect("/login")
    # purchases = get_all_purchases()
    vendors = get_all_vendors(only_active=True)
    return render_template('purchase_list.html', vendors=vendors, user=session["user"])


@app.route('/purchase_record')
def purchase_record():
    if "user" not in session:
        return redirect("/login")
    # purchases = get_all_purchases()
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    contact_details = get_contact_details()
    return render_template('purchase_record.html', user=session["user"], contact_details=contact_details, vendors=vendors, today_date=today_date)


@app.route("/get_purchase_transaction", methods=["GET"])
def get_purchase_transaction():
    date = request.args.get("date")
    transactions, total_purchase_amount = get_purchase_record(date=date)
    return jsonify({"purchases": transactions, "total_amount": total_purchase_amount})


@app.route("/get_purchase_records", methods=["GET"])
def fetch_purchase_records():
    vendor_id = request.args.get("vendor_id", "all")
    from_date = request.args.get("from_date")
    to_date = request.args.get("to_date")

    if not from_date or not to_date:
        return jsonify({"error": "Invalid date range"}), 400

    try:
        datetime.strptime(from_date, "%Y-%m-%d")
        datetime.strptime(to_date, "%Y-%m-%d")
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    purchases, vendor_totals = get_purchase_records(vendor_id, from_date, to_date)

    return jsonify({
        "purchases": purchases,
        "vendor_totals": vendor_totals
    })


@app.route("/get_payment_records", methods=["GET"])
def fetch_payment_records():
    vendor_id = request.args.get("vendor_id", "all")
    from_date = request.args.get("from_date")
    to_date = request.args.get("to_date")

    if not from_date or not to_date:
        return jsonify({"error": "Invalid date range"}), 400

    try:
        datetime.strptime(from_date, "%Y-%m-%d")
        datetime.strptime(to_date, "%Y-%m-%d")
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    payments, vendor_totals = get_payment_records(vendor_id, from_date, to_date)

    return jsonify({"payments": payments, "vendor_totals": vendor_totals})


@app.route("/get_pending_payments_record", methods=["GET"])
def fetch_pending_payments_record():
    vendor_id = request.args.get("vendor_id", "all")

    # from_date = request.args.get("from_date")
    # to_date = request.args.get("to_date")

    # if not from_date or not to_date:
    #     return jsonify({"error": "Invalid date range"}), 400

    # try:
    #     datetime.strptime(from_date, "%Y-%m-%d")
    #     datetime.strptime(to_date, "%Y-%m-%d")
    # except ValueError:
    #     return jsonify({"error": "Invalid date format"}), 400

    pending_payments, vendor_totals = get_pending_payments_record(vendor_id)

    return jsonify({"payments": pending_payments, "vendor_totals": vendor_totals})


@app.route("/get_payment_transaction", methods=["GET"])
def get_payment_transaction():
    date = request.args.get("date")

    transactions, total_paid_amount = get_payment_record_on_date(date=date)

    return jsonify({"payments": transactions, "total_amount": total_paid_amount})


@app.route("/pay_vendor", methods=["GET", "POST"])
def pay_vendor():
    if "user" not in session:
        return redirect("/login")
    # if request.method == "POST":
    #     # Handle form submission
    #     vendor_id = request.json.get("vendorId")
    #     vendor_name = request.json.get("vendorName")
    #     amount_paid = float(request.json.get("amountPaid"))
    #     connection = get_db_connection()
    #     cursor = connection.cursor()
    #     cursor.execute(
    #         """
    #             INSERT INTO vendor_payment_tracker (vendor_id, total_paid)
    #             VALUES (%s, %s)
    #             ON DUPLICATE KEY UPDATE total_paid = total_paid + %s
    #             """,
    #         (vendor_id, amount_paid, amount_paid)
    #     )
    #     connection.commit()
    #     cursor.close()
    #     connection.close()
    #     flash('Payment done successfully!', "success")
    #     return redirect(url_for("pending_payments"))
    pending_payments_vendor_cumulative = get_all_pending_payments_vendor_cumulative()
    return render_template("pay_vendor.html", user=session["user"], pending_payments_vendor_cumulative=pending_payments_vendor_cumulative, todays_date=get_current_date())


@app.route("/pending_payments", methods=["GET", "POST"])
def pending_payments():
    if "user" not in session:
        return redirect("/login")
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    contact_details = get_contact_details()
    return render_template('pending_payments.html', user=session["user"], contact_details=contact_details, vendors=vendors, today_date=today_date)


@app.route("/process_payments", methods=["POST"])
def process_payments():
    # try:
    if request.method == "POST":
        vendor_id = request.json.get("vendor_id")
        paid_values = []
        for payment in request.json.get("payments", []):
            if payment["pay_amount"] > 0:
                paid_values.append(payment)

        connection = get_db_connection()
        cursor = connection.cursor()
        for payment_detail in paid_values:
            cursor.execute(
                """
                    INSERT INTO vendor_payment_tracker (vendor_id, invoice_number, purchase_date, total_paid)
                    VALUES (%s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE total_paid = total_paid + %s
                    """,
                (vendor_id, payment_detail["invoice_number"], payment_detail["purchase_date"],
                 payment_detail["pay_amount"], payment_detail["pay_amount"])
            )
            cursor.execute(
                """
                    INSERT INTO payment_records (vendor_id, invoice_number, purchase_date, amount_paid, mode_of_payment, paid_on)
                    VALUES (%s, %s, %s, %s, %s, %s)
                    """,
                (vendor_id, payment_detail["invoice_number"], payment_detail["purchase_date"],
                    payment_detail["pay_amount"], payment_detail["mode_of_payment"], payment_detail["date_of_payment"])
            )
        connection.commit()
        cursor.close()
        connection.close()
        flash('Payment processed successfully!', 'success')
        return jsonify({'message': 'Payment processed successfully'}), 200
    # except Exception as e:
    #     flash(f'An error occurred while processing the payment. Please try again. {str(e)}', 'error')
    #     return jsonify({'error': str(e)}), 400


@app.route('/storageroom_stock')
def storageroom_stock():
    if "user" not in session:
        return redirect("/login")
    storage_stock = get_storageroom_stock()

    return render_template('storageroom_stock.html', storage_stock=storage_stock, user=session["user"])


@app.route('/kitchen_inventory_stock')
def kitchen_inventory_stock():
    if "user" not in session:
        return redirect("/login")
    kitcheninv_stock = get_kitchen_inventory_stock()

    return render_template('kitchen_inventory_stock.html', kitcheninv_stock=kitcheninv_stock, user=session["user"])


@app.route('/get_vendor_payments', methods=["GET"])
def get_vendor_payments():
    vendor_id = request.args.get('vendor_id')
    from_date = request.args.get('from_date')
    to_date = request.args.get('to_date')

    # Convert string dates to datetime objects
    try:
        from_date = datetime.strptime(from_date, '%Y-%m-%d')
        to_date = datetime.strptime(to_date, '%Y-%m-%d')
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    # Fetch payment records for the given vendor and date range
    payments_per_vendor = get_payment_details_of_vendor_between_dates(vendor_id, from_date, to_date)

    def serialize(payment):
        return {
            'paid_on': payment['paid_on'].strftime('%Y-%m-%d'),
            'invoice_number': payment['invoice_number'],
            'purchase_date': payment['purchase_date'],
            'mode_of_payment': payment['mode_of_payment'],
            'amount_paid': float(payment['amount_paid'])
        }

    return jsonify({'payments': [serialize(p) for p in payments_per_vendor]})


@app.route("/get_payment_details/<vendor_id>", methods=["GET"])
def get_payment_details(vendor_id):
    # vendor_id = request.args.get('vendor_id')

    payments_per_vendor = get_payment_details_of_vendor(vendor_id)

    def serialize(payment):
        return {
            'payment_id': payment['payment_id'],
            'invoice_number': payment['invoice_number'],
            'purchase_date': payment['purchase_date'],
            'outstanding_cost': float(payment['outstanding_cost']),
            'total_paid': float(payment['total_paid']),
            'total_due': float(payment['total_due'])
        }

    return jsonify([serialize(p) for p in payments_per_vendor])


@app.route("/payment_receipt")
def payment_receipt():
    if "user" not in session:
        return redirect("/login")
    # inv_payment_details = get_invoice_payment_details()
    vendors = get_all_vendors(only_active=True)
    contact_details = get_contact_details()
    return render_template('payment_receipt.html', vendors=vendors, contact_details=contact_details, user=session["user"])


@app.route("/payment_record")
def payment_record():
    if "user" not in session:
        return redirect("/login")
    # payment_record = get_payment_record()
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    contact_details = get_contact_details()
    return render_template('payment_record.html', user=session["user"], vendors=vendors, contact_details=contact_details, today_date=today_date)


@app.route('/restaurant_inventory_stock')
def restaurant_inventory_stock():
    if "user" not in session:
        return redirect("/login")
    restaurantinv_stock = get_restaurant_inventory_stock()

    return render_template('restaurant_inventory_stock.html', restaurantinv_stock=restaurantinv_stock, user=session["user"])


@app.route("/set_minimum_stock", methods=["GET", "POST"])
def set_minimum_stock():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        # try:
        destination_type = request.form.get("destination_type")
        destination_id = request.form.get("destination_id")
        min_stock_data = {}
        for key, value in request.form.items():

            if key.startswith("min_quantity_"):

                material_id = key.replace("min_quantity_", "")

                min_stock_data[material_id] = float(value)

        result = update_minimum_stock(destination_type, destination_id, min_stock_data)
        if result:
            flash("Minimum stock updated successfully!", "success")
        else:
            flash("Error: Unable to add minimum stock details", "danger")
        # except Exception as e:
        #     flash(f"Error: {str(e)}", "danger")
        return redirect(url_for("set_minimum_stock"))
    return render_template(
        'set_minimum_stock.html',
        raw_materials=get_all_rawmaterials(),
        storage_rooms=get_all_storagerooms(only_active=True),
        restaurants=get_all_restaurants(only_active=True),
        kitchens=get_all_kitchens(only_active=True),
        user=session["user"],
        today_date=get_current_date()
    )


@app.route("/get_raw_materials_min_stock")
def fetch_raw_materials_min_stock():
    if "user" not in session:
        return redirect("/login")

    # Fetch query parameters from request
    destination_type = request.args.get("destination_type")
    destination_id = request.args.get("destination_id")

    if not destination_type or not destination_id:
        return jsonify({"error": "Missing required parameters"}), 400

    # Fetch raw materials with minimum stock details
    rm = get_raw_materials_min_stock(destination_type, destination_id)

    return jsonify(rm)  # Return as JSON response


@app.route("/get_raw_materials_stock_report")
def fetch_raw_materials_stock_report():
    if "user" not in session:
        return redirect("/login")

    # Fetch query parameters from request
    destination_type = request.args.get("destination_type")
    destination_id = request.args.get("destination_id")
    category = request.args.get("category")

    if not destination_type or not destination_id or not category:
        return jsonify({"error": "Missing required parameters"}), 400

    # Fetch raw materials with minimum stock details
    rm = get_raw_materials_stock_report(destination_type, destination_id, category)

    return jsonify(rm)  # Return as JSON response

# Utility function for converting metric units


def convert_to_base_units(quantity, metric):
    if metric == "grams":
        return quantity / 1000  # Convert grams to kg
    elif metric == "ml":
        return quantity / 1000  # Convert ml to liters
    return quantity  # Return as is for kg, liters, and units


@app.route('/transfer_raw_material', methods=['GET', 'POST', 'PUT'])
def transfer_raw_material():
    if "user" not in session:
        return redirect("/login")
      
    if request.method == 'POST':
        source_storeroom_id = request.form.get("storageroom")
        destination_type = request.form.get("destination_type")
        destination_id = request.form.get("destination_name")
        transfer_date = request.form.get("transfer_date")
        raw_materials = request.form.getlist("raw_material_id[]")
        quantities = request.form.getlist("quantity[]")
        metrics = request.form.getlist("metric[]")
        transfer_avgs = request.form.getlist("transfer_avgs[]") or [0.0]
        total_costs = request.form.getlist("total_cost[]") or [0.0]
        transfer_datetime = get_current_datetime()
        connection = get_db_connection()

        try:
            with connection.cursor() as cursor:
                # Step 1: Get the latest transfer_id for today
                cursor.execute("""
                    SELECT IFNULL(MAX(transfer_id), 0) + 1
                    FROM raw_material_transfer_details
                    WHERE transferred_date = %s
                    AND source_storage_room_id = %s
                """, (transfer_date, source_storeroom_id))
                next_transfer_id = cursor.fetchone()[0]  # Get next transfer ID

                # Step 2: Prepare Transfer Details
                transfer_status = "APPROVED"

                if session['user']["role"] == 'branch_manager':
                    transfer_status = 'PENDING'

                transfer_details = [
                    (source_storeroom_id, destination_type, destination_id,
                     raw_material, Decimal(convert_to_base_units(quantity, metric)),
                     metric, transfer_date, transfer_datetime, next_transfer_id, transfer_avg, total_cost , transfer_status)
                    for raw_material, quantity, metric, transfer_avg,total_cost in zip(raw_materials, quantities, metrics,transfer_avgs, total_costs)
                ]

                # Step 3: Bulk INSERT into `raw_material_transfer_details`
            
                insert_transfer_sql = """
                    INSERT INTO raw_material_transfer_details
                        (source_storage_room_id, destination_type, destination_id,
                        raw_material_id, quantity, metric, transferred_date, transfer_time, transfer_id, transfer_avg, total_cost , transfer_status )
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s , %s , %s ,%s )
                """

                inserted_ids = []

                for detail in transfer_details:
                    cursor.execute(insert_transfer_sql, detail)
                    inserted_ids.append(cursor.lastrowid)  # capture ID

                print(f"inserted_id - : '{inserted_ids}'")


                # Step 3.2: Prepare data for raw_material_transfer_request_details
                if session['user']["role"] == 'branch_manager':

                    transfer_datetime = get_current_datetime()

                    user_email = session['user']["email"]
                    print(f"user_id - : '{user_email}'")

                    request_details = [
                        (transfer_id, user_email, transfer_datetime, None, None , transfer_id)
                        for transfer_id in inserted_ids
                    ]

                    print(f"request_details - : '{request_details}'")

                    # Step 3.3: Bulk INSERT into raw_material_transfer_request_details
                    insert_request_sql = """
                        INSERT INTO raw_material_transfer_request_details
                            (transfer_id, user_email, requested_date_time, approved_date_time, rejected_date_time , request_id)
                        VALUES (%s, %s, %s, %s, %s ,  
                                (SELECT transfer_id
                                            FROM raw_material_transfer_details
                                WHERE id = %s))
                        """
                    
                    for detail in request_details:
                        cursor.execute(insert_request_sql, detail)



                # Step 4: Update inventory_stock
                # raw_material_ids = [item[3] for item in transfer_details]
                # raw_material_ids_str = ",".join(map(str, raw_material_ids))  # Convert to comma-separated string

                # case_statements_outgoing = " ".join([f"WHEN {item[3]} THEN {item[4]}" for item in transfer_details])
                # case_statements_available = case_statements_outgoing  # Same logic for both columns

                # update_inventory_sql = f"""
                #     UPDATE inventory_stock
                #     SET 
                #         outgoing_stock = outgoing_stock + CASE raw_material_id 
                #             {case_statements_outgoing} ELSE outgoing_stock END,
                #         currently_available = currently_available - CASE raw_material_id 
                #             {case_statements_available} ELSE 0 END, 
                        
                #         total_stock_value = total_stock_value - CASE raw_material_id
                #             {" ".join([f"WHEN {item[3]} THEN {item[10]}" for item in transfer_details])} ELSE 0 END,

                #         average_unit_cost = CASE 
                #              WHEN (currently_available - CASE raw_material_id 
                #             {case_statements_available} ELSE 0 END) > 0
                #         THEN 
                #             (total_stock_value - CASE raw_material_id
                #             {" ".join([f"WHEN {item[3]} THEN {item[10]}" for item in transfer_details])} ELSE 0 END)
                #             / 
                #             (currently_available - CASE raw_material_id 
                #             {case_statements_available} ELSE 0 END)
                #         ELSE 0
                #         END,
           
                #         updated_at = CURRENT_TIMESTAMP
                #     WHERE destination_type = 'storageroom' 
                #     AND destination_id = %s
                #     AND raw_material_id IN ({raw_material_ids_str})
                # """

                # cursor.execute(update_inventory_sql, (source_storeroom_id,))

                # # Step 5: Fetch current inventory details
                # fetch_inventory_sql = f"""
                #     SELECT raw_material_id, 
                #         IFNULL(currently_available, 0),
                #         IFNULL(minimum_quantity, 0), 
                #         IFNULL(quantity_needed, 0) 
                #     FROM inventory_stock 
                #     WHERE destination_type = %s 
                #     AND destination_id = %s 
                #     AND raw_material_id IN ({raw_material_ids_str})
                # """

                # cursor.execute(fetch_inventory_sql, (destination_type, destination_id))
                # existing_inventory = {row[0]: (Decimal(row[1]), Decimal(row[2]), Decimal(row[3]))
                #                       for row in cursor.fetchall()}  # Convert to Decimal

                # # Step 6: Bulk INSERT or UPDATE inventory_stock
                # insert_inventory_sql = """
                #     INSERT INTO inventory_stock
                #         (destination_type, destination_id, raw_material_id, metric,
                #         incoming_stock, currently_available, minimum_quantity, quantity_needed, updated_at)
                #     VALUES (%s, %s, %s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP)
                #     ON DUPLICATE KEY UPDATE
                #         incoming_stock = incoming_stock + VALUES(incoming_stock),
                #         currently_available = COALESCE(currently_available, 0) + VALUES(incoming_stock),
                #         updated_at = CURRENT_TIMESTAMP
                # """
                
                # inventory_values = [
                #     (item[1], item[2], item[3], item[5], Decimal(item[4]),  # Ensure quantity is Decimal
                #      existing_inventory.get(item[3], (Decimal(0), Decimal(0), Decimal(0)))[
                #         0] + Decimal(item[4]),  # Compute currently_available
                #      existing_inventory.get(item[3], (Decimal(0), Decimal(0), Decimal(0)))[
                #         1],  # Fetch minimum_quantity if exists, else 0
                #      existing_inventory.get(item[3], (Decimal(0), Decimal(0), Decimal(0)))[2])  # Fetch quantity_needed if exists, else 0
                     
                #     for item in transfer_details
                # ]

                # cursor.executemany(insert_inventory_sql, inventory_values)

                connection.commit()
                flash(f"Transfer successful (Transfer ID: {next_transfer_id})", "success")

        except Exception as e:
            connection.rollback()
            app.logger.error(f"Database Error: {e}")
            flash(f"An error occurred: {e}", "danger")

        finally:
            connection.close()

        return redirect('/transfer_raw_material')

    # GET request - Load necessary data
    return render_template(
        'transfer_raw_material.html',
        raw_materials=get_all_rawmaterials(),
        storage_rooms=get_all_storagerooms(only_active=True),
        restaurants=get_all_restaurants(only_active=True),
        kitchens=get_all_kitchens(only_active=True),
        user=session["user"],
        today_date=get_current_date()
    )

@app.route("/raw_material_transfers", methods=["GET"])
def get_raw_material_transfers():
    if "user" not in session:
        return redirect("/login")

    # Get filter parameters
    transfer_status = request.args.get("transfer_status")
    page = int(request.args.get("page", 1))
    per_page = int(request.args.get("per_page", 500))
    requested_user_email = request.args.get("requested_user_email")
    
    conn = get_db_connection()
    try:
        cursor = conn.cursor(dictionary=True)

        # Get current stock value
        cursor.execute("""
            SELECT SUM(total_stock_value) AS current_total_value 
            FROM inventory_stock 
            WHERE destination_type = 'storageroom'
        """)
        stock_result = cursor.fetchone()
        current_total_value = stock_result['current_total_value'] if stock_result and stock_result['current_total_value'] else 0

        # Default to PENDING if no status is provided
        if not transfer_status:
            transfer_status = 'PENDING'

        # Determine ordering column based on status
        if transfer_status == 'PENDING':
            order_column_name = "rmtrq.requested_date_time"
        elif transfer_status == 'REJECTED':
            order_column_name = "rmtrq.rejected_date_time"
        else:
            order_column_name = "rmtrq.approved_date_time"

        transfer_status = transfer_status or 'APPROVED'
        offset = (page - 1) * per_page

        # Build WHERE conditions
        where_conditions = ["rmtd.id = rmtrq.transfer_id"]
        params = []
        
        if transfer_status:
            where_conditions.append("rmtd.transfer_status = %s")
            params.append(transfer_status)
            
        if requested_user_email:
            where_conditions.append("rmtrq.user_email = %s")
            params.append(requested_user_email)

        where_clause = " AND ".join(where_conditions)

        # Count total rows for pagination
        count_sql = f"""
            SELECT COUNT(*) AS total
            FROM raw_material_transfer_details rmtd
            INNER JOIN raw_material_transfer_request_details rmtrq ON {where_clause}
            INNER JOIN storagerooms s ON s.id = rmtd.source_storage_room_id
            INNER JOIN raw_materials r ON r.id = rmtd.raw_material_id
            INNER JOIN inventory_stock i ON i.raw_material_id = rmtd.raw_material_id AND i.destination_type = 'storageroom'
        """
        cursor.execute(count_sql, tuple(params))
        total_row = cursor.fetchone()
        total = total_row["total"] if total_row else 0
        total_pages = ceil(total / per_page) if per_page > 0 else 0

        # Fetch paginated transfers
        query = f"""
            SELECT 
                rmtd.id AS transfer_id,
                rmtrq.request_id AS no_of_time_requested,
                rmtrq.id AS request_id,
                rmtd.transfer_status,
                rmtd.transferred_date,
                s.storageroomname,
                rmtd.destination_type,
                rmtd.destination_type AS destination_id,
                r.name AS raw_material_name,
                i.currently_available AS current_available_quantity,
                rmtd.quantity,
                rmtd.metric,
                i.average_unit_cost,
                rmtd.transfer_avg,
                rmtrq.requested_date_time,
                rmtrq.approved_date_time,
                rmtrq.rejected_date_time,
                rmtrq.user_email AS requested_user_email_id
            FROM raw_material_transfer_details rmtd
            INNER JOIN raw_material_transfer_request_details rmtrq ON {where_clause}
            INNER JOIN storagerooms s ON s.id = rmtd.source_storage_room_id
            INNER JOIN raw_materials r ON r.id = rmtd.raw_material_id
            INNER JOIN inventory_stock i ON i.raw_material_id = rmtd.raw_material_id AND i.destination_type = 'storageroom'
            ORDER BY {order_column_name} DESC
            LIMIT %s OFFSET %s
        """
        cursor.execute(query, tuple(params + [per_page, offset]))
        results = cursor.fetchall()

        # Generate daily batch numbers
        daily_batches = {}
        grouped_transfers = {}
        
        for transfer in results:
            # Extract date from requested_date_time
            request_date = transfer['requested_date_time'].date() if transfer['requested_date_time'] else None
            
            if not request_date:
                # Fallback to current date if no date available
                request_date = datetime.now().date()
            
            date_key = request_date.strftime('%Y-%m-%d')
            
            # Create daily batch identifier
            if date_key not in daily_batches:
                daily_batches[date_key] = {}
            
            original_batch_id = transfer['no_of_time_requested']
            
            # Assign new daily sequential batch number
            if original_batch_id not in daily_batches[date_key]:
                daily_batches[date_key][original_batch_id] = len(daily_batches[date_key]) + 1
            
            daily_batch_number = daily_batches[date_key][original_batch_id]
            
            # Create unique batch key combining date and daily batch number
            batch_key = f"{date_key}-{daily_batch_number}"
            
            # Add daily batch info to transfer record with new format
            transfer['daily_batch_id'] = batch_key
            transfer['daily_batch_number'] = daily_batch_number
            transfer['batch_date'] = date_key
            transfer['display_batch_name'] = f"Daily Batch {daily_batch_number}: {date_key}"
            
            # Group transfers by daily batch
            if batch_key not in grouped_transfers:
                grouped_transfers[batch_key] = []
            
            grouped_transfers[batch_key].append(transfer)

        return render_template(
            'raw_material_transfers.html',
            transfers=results,
            grouped_transfers=grouped_transfers,
            transfer_status=transfer_status or 'APPROVED',
            page=page,
            per_page=per_page,
            total=total,
            total_pages=total_pages,
            user=session["user"],
            current_total_value=current_total_value
        )
        
    except Exception as e:
        app.logger.error(f"Error in get_raw_material_transfers: {e}")
        flash(f"An error occurred: {str(e)}", "danger")
        return render_template(
            'raw_material_transfers.html',
            transfers=[],
            grouped_transfers={},
            transfer_status=transfer_status or 'APPROVED',
            page=page,
            per_page=per_page,
            total=0,
            total_pages=0,
            user=session["user"],
            current_total_value=0,
            error=str(e)
        )
    finally:
        conn.close()

# @app.route("/raw_material_transfers", methods=["GET"])
# def get_raw_material_transfers():
#     if "user" not in session:
#         return redirect("/login")
    
#     # Get filter parameters
#     transfer_status = request.args.get("transfer_status")
#     page = int(request.args.get("page", 1))
#     per_page = int(request.args.get("per_page", 500))
#     requested_user_email = request.args.get("requested_user_email")

#     conn = get_db_connection()
    
#     try:
#         cursor = conn.cursor(dictionary=True)

#         # Get current stock value
#         cursor.execute("""
#             SELECT SUM(total_stock_value) AS current_total_value
#             FROM inventory_stock 
#             WHERE destination_type = 'storageroom'
#         """)
#         stock_result = cursor.fetchone()
#         current_total_value = stock_result['current_total_value'] if stock_result and stock_result['current_total_value'] else 0

#         # Default to PENDING if no status is provided
#         if not transfer_status:
#             transfer_status = 'PENDING'

#         # Determine ordering column based on status
#         if transfer_status == 'PENDING':
#             order_column_name = "rmtrq.requested_date_time"
#         elif transfer_status == 'REJECTED':
#             order_column_name = "rmtrq.rejected_date_time"
#         else:
#             order_column_name = "rmtrq.approved_date_time"
#             transfer_status = transfer_status or 'APPROVED'

#         offset = (page - 1) * per_page

#         # Build WHERE conditions
#         where_conditions = ["rmtd.id = rmtrq.transfer_id"]
#         params = []

#         if transfer_status:
#             where_conditions.append("rmtd.transfer_status = %s")
#             params.append(transfer_status)

#         if requested_user_email:
#             where_conditions.append("rmtrq.user_email = %s")
#             params.append(requested_user_email)

#         where_clause = " AND ".join(where_conditions)

#         # Count total rows for pagination
#         count_sql = f"""
#             SELECT COUNT(*) AS total
#             FROM raw_material_transfer_details rmtd
#             INNER JOIN raw_material_transfer_request_details rmtrq
#                 ON {where_clause}
#             INNER JOIN storagerooms s
#                 ON s.id = rmtd.source_storage_room_id
#             INNER JOIN raw_materials r
#                 ON r.id = rmtd.raw_material_id
#             INNER JOIN inventory_stock i
#                 ON i.raw_material_id = rmtd.raw_material_id AND i.destination_type = 'storageroom'
#         """
#         cursor.execute(count_sql, tuple(params))
#         total_row = cursor.fetchone()
#         total = total_row["total"] if total_row else 0
#         total_pages = ceil(total / per_page) if per_page > 0 else 0

#         # Fetch paginated transfers
#         query = f"""
#             SELECT rmtd.id AS transfer_id,
#                    rmtrq.request_id AS no_of_time_requested,
#                    rmtrq.id AS request_id,
#                    rmtd.transfer_status,
#                    rmtd.transferred_date,
#                    s.storageroomname,
#                    rmtd.destination_type,
#                    rmtd.destination_type AS destination_id,
#                    r.name AS raw_material_name,
#                    i.currently_available AS current_available_quantity,
#                    rmtd.quantity,
#                    rmtd.metric,
#                    i.average_unit_cost,
#                    rmtd.transfer_avg,
#                    rmtrq.requested_date_time,
#                    rmtrq.approved_date_time,
#                    rmtrq.rejected_date_time,
#                    rmtrq.user_email AS requested_user_email_id
#             FROM raw_material_transfer_details rmtd
#             INNER JOIN raw_material_transfer_request_details rmtrq
#                 ON {where_clause}
#             INNER JOIN storagerooms s
#                 ON s.id = rmtd.source_storage_room_id
#             INNER JOIN raw_materials r
#                 ON r.id = rmtd.raw_material_id
#             INNER JOIN inventory_stock i
#                 ON i.raw_material_id = rmtd.raw_material_id AND i.destination_type = 'storageroom'
#             ORDER BY {order_column_name} DESC
#             LIMIT %s OFFSET %s
#         """
#         cursor.execute(query, tuple(params + [per_page, offset]))
#         results = cursor.fetchall()

#         # Build grouped_transfers dictionary for template
#         grouped_transfers = {}
#         for transfer in results:
#             batch_id = transfer['no_of_time_requested']
#             if batch_id not in grouped_transfers:
#                 grouped_transfers[batch_id] = []
#             grouped_transfers[batch_id].append(transfer)

#         return render_template(
#             'raw_material_transfers.html',
#             transfers=results,
#             grouped_transfers=grouped_transfers,  # ‚úÖ Pass this to template
#             transfer_status=transfer_status or 'APPROVED',
#             page=page,
#             per_page=per_page,
#             total=total,
#             total_pages=total_pages,
#             user=session["user"],
#             current_total_value=current_total_value
#         )

#     except Exception as e:
#         app.logger.error(f"Error in get_raw_material_transfers: {e}")
#         flash(f"An error occurred: {str(e)}", "danger")
#         return render_template(
#             'raw_material_transfers.html',
#             transfers=[],
#             grouped_transfers={},  # provide empty dict on error
#             transfer_status=transfer_status or 'APPROVED',
#             page=page,
#             per_page=per_page,
#             total=0,
#             total_pages=0,
#             user=session["user"],
#             current_total_value=0,
#             error=str(e)
#         )

#     finally:
#         conn.close()

from decimal import Decimal, ROUND_HALF_UP

def clamp_decimal(value, max_value, scale):
    """Clamp value within [0, max_value] and round to given scale"""
    if value < 0:
        value = Decimal("0")
    if value > Decimal(max_value):
        value = Decimal(max_value)
    return value.quantize(Decimal(scale), rounding=ROUND_HALF_UP)


@app.route("/approve_transfers", methods=["PUT"])
def approve_transfers():
    data = request.get_json()
    transfer_ids = data.get("transfer_ids", [])

    if not transfer_ids:
        return jsonify({"error": "No transfer IDs provided"}), 400

    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    try:
        placeholders = ",".join(["%s"] * len(transfer_ids))

        # Step 1: Fetch transfer details by id
        fetch_transfer_sql = f"""
            SELECT *
            FROM raw_material_transfer_details
            WHERE id IN ({placeholders})
        """
        cursor.execute(fetch_transfer_sql, tuple(transfer_ids))
        transfer_details = cursor.fetchall()

        if not transfer_details:
            return jsonify({"error": "No transfers found for these IDs"}), 404

        for item in transfer_details:
            raw_id = item['raw_material_id']
            quantity = Decimal(item['quantity'])
            total_cost = Decimal(item['total_cost'])
            metric = item['metric']

            source_type = "storageroom"
            dest_type = item['destination_type']
            dest_id = item['destination_id']

            # =============================
            # Step 2A: Deduct from storageroom
            # =============================
            fetch_source_sql = """
                SELECT raw_material_id, currently_available, incoming_stock, outgoing_stock, total_stock_value
                FROM inventory_stock
                WHERE destination_type = %s
                  AND raw_material_id = %s
            """
            cursor.execute(fetch_source_sql, (source_type, raw_id))
            source_inv = cursor.fetchone()

            if source_inv:
                currently_available = Decimal(source_inv['currently_available']) - quantity
                outgoing_stock = Decimal(source_inv['outgoing_stock']) + quantity
                total_stock_value = Decimal(source_inv['total_stock_value']) - total_cost

                # clamp values based on schema
                currently_available = clamp_decimal(currently_available, "99999.99999", "0.00001")
                outgoing_stock = clamp_decimal(outgoing_stock, "99999.99999", "0.00001")
                total_stock_value = clamp_decimal(total_stock_value, "9999999999.99", "0.01")

                average_unit_cost = (total_stock_value / currently_available
                                     if currently_available > 0 else Decimal("0.00"))
                average_unit_cost = clamp_decimal(average_unit_cost, "9999999999.99", "0.01")

                update_source_sql = """
                    UPDATE inventory_stock
                    SET currently_available = %s,
                        outgoing_stock = %s,
                        total_stock_value = %s,
                        average_unit_cost = %s,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE destination_type = %s
                      AND raw_material_id = %s
                """
                cursor.execute(update_source_sql, (
                    currently_available, outgoing_stock,
                    total_stock_value, average_unit_cost,
                    source_type, raw_id
                ))

            # =============================
            # Step 2B: Add to destination
            # =============================
            fetch_dest_sql = """
                SELECT raw_material_id, currently_available, incoming_stock, total_stock_value
                FROM inventory_stock
                WHERE destination_type = %s
                  AND destination_id = %s
                  AND raw_material_id = %s
            """
            cursor.execute(fetch_dest_sql, (dest_type, dest_id, raw_id))
            dest_inv = cursor.fetchone()

            if dest_inv:
                currently_available = Decimal(dest_inv['currently_available']) + quantity
                incoming_stock = Decimal(dest_inv['incoming_stock']) + quantity
                total_stock_value = Decimal(dest_inv['total_stock_value']) + total_cost

                currently_available = clamp_decimal(currently_available, "99999.99999", "0.00001")
                incoming_stock = clamp_decimal(incoming_stock, "99999.99999", "0.00001")
                total_stock_value = clamp_decimal(total_stock_value, "9999999999.99", "0.01")

                average_unit_cost = (total_stock_value / currently_available
                                     if currently_available > 0 else Decimal("0.00"))
                average_unit_cost = clamp_decimal(average_unit_cost, "9999999999.99", "0.01")

                update_dest_sql = """
                    UPDATE inventory_stock
                    SET currently_available = %s,
                        incoming_stock = %s,
                        total_stock_value = %s,
                        average_unit_cost = %s,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE destination_type = %s
                      AND destination_id = %s
                      AND raw_material_id = %s
                """
                cursor.execute(update_dest_sql, (
                    currently_available, incoming_stock,
                    total_stock_value, average_unit_cost,
                    dest_type, dest_id, raw_id
                ))
            else:
                avg_cost = (total_cost / quantity) if quantity > 0 else Decimal("0.00")
                avg_cost = clamp_decimal(avg_cost, "9999999999.99", "0.01")

                quantity = clamp_decimal(quantity, "99999.99999", "0.00001")
                total_cost = clamp_decimal(total_cost, "9999999999.99", "0.01")

                insert_dest_sql = """
                    INSERT INTO inventory_stock
                        (destination_type, destination_id, raw_material_id, metric,
                         opening_stock, incoming_stock, outgoing_stock,
                         currently_available, minimum_quantity, quantity_needed,
                         total_stock_value, average_unit_cost, created_at, updated_at)
                    VALUES (%s, %s, %s, %s, 0, %s, 0, %s, 0, 0, %s, %s, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                """
                cursor.execute(insert_dest_sql, (
                    dest_type, dest_id, raw_id, metric,
                    quantity, quantity, total_cost, avg_cost
                ))

        # Step 3: Approve transfers
        approved_time_sql = f"""
            UPDATE raw_material_transfer_request_details
            SET approved_date_time = NOW()
            WHERE transfer_id IN ({placeholders})
        """
        cursor.execute(approved_time_sql, tuple(transfer_ids))

        transfer_status_sql = f"""
            UPDATE raw_material_transfer_details
            SET transfer_status = 'APPROVED'
            WHERE id IN ({placeholders})
        """
        cursor.execute(transfer_status_sql, tuple(transfer_ids))

        conn.commit()
        return jsonify({"message": "Transfers approved, storageroom reduced, and destination updated"}), 200

    except Exception as e:
        conn.rollback()
        return jsonify({"error": str(e)}), 500
    finally:
        cursor.close()
        conn.close()

@app.route("/reject", methods=["POST"])
def reject_transfers():
    data = request.get_json()
    transfer_ids = data.get("transfer_ids", [])

    conn = get_db_connection()
    cursor = conn.cursor()

    if not transfer_ids:
        return jsonify({"error": "No transfer IDs provided"}), 400

    try:
      
        placeholders = ",".join(["%s"] * len(transfer_ids))

        # Step 4: Update transfer status to REJECTED
        update_transfer_sql = f"""
            UPDATE raw_material_transfer_details
            SET transfer_status = 'REJECTED'
            WHERE id IN ({placeholders})
        """
        
        cursor.execute(update_transfer_sql, tuple(transfer_ids))
        
        update_sql = f"""
        UPDATE raw_material_transfer_request_details
        SET rejected_date_time = NOW()
        WHERE transfer_id IN ({placeholders})
    """
        cursor.execute(update_sql, tuple(transfer_ids))


        conn.commit()
        return jsonify({"message": "Transfers rejected and inventory updated successfully"}), 200

    except Exception as e:
        conn.rollback()
        return jsonify({"error": str(e)}), 500

    finally:
        cursor.close()
        conn.close()

@app.route('/list_rawmaterial_transfers', methods=["GET", "POST"])
def list_rawmaterial_transfers():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        selected_date = request.form['transfer_date']
        transfers = get_rawmaterial_transfer_history(selected_date)
        return render_template('list_rawmaterial_transfers.html', transfers=transfers, current_date=selected_date, user=session["user"])
    return render_template('list_rawmaterial_transfers.html', user=session["user"])

@app.route('/list_rawmaterial_transfers_range', methods=["GET", "POST"])
def list_rawmaterial_transfers_range():
    if "user" not in session:
        return redirect("/login")

    contact_details = get_contact_details()
    kitchens = fetch_all("SELECT id, kitchenname FROM kitchen;", ()) or []
    restaurants = fetch_all("SELECT id, restaurantname FROM restaurant;", ()) or []

    range_transfers = []
    grand_total_qty = 0
    grand_total_cost = 0
    grand_total_avg = 0

    if request.method == "POST":
        from_date = request.form.get('from_date')
        to_date = request.form.get('to_date')
        destination_type = request.form.get('destination_type')
        destination_name = request.form.get('destination_name')

        if from_date and to_date and destination_type and destination_name:
            range_transfers = get_rawmaterial_transfer_history_range(
                from_date, to_date, destination_type, destination_name
            )

            # Calculate grand totals
            grand_total_qty = sum(t['quantity'] for t in range_transfers if t['quantity'])
            grand_total_cost = sum(t['total_cost'] for t in range_transfers if t['total_cost'])
            # average of transfer_avg (not sum)
            transfer_avgs = [t['transfer_avg'] for t in range_transfers if t['transfer_avg']]
            grand_total_avg = sum(transfer_avgs) / len(transfer_avgs) if transfer_avgs else 0

        return render_template(
            'list_rawmaterial_transfers_range.html',
            range_transfers=range_transfers,
            kitchens=kitchens,
            restaurants=restaurants,
            user=session["user"],
            from_date=from_date,
            to_date=to_date,
            destination_type=destination_type,
            destination_name=destination_name,
            grand_total_qty=grand_total_qty,
            grand_total_cost=grand_total_cost,
            grand_total_avg=grand_total_avg,
            contact_details=contact_details,
        )

    # For GET load
    return render_template(
        'list_rawmaterial_transfers_range.html',
        range_transfers=[],
        kitchens=kitchens,
        restaurants=restaurants,
        user=session["user"],
        from_date=None,
        to_date=None,
        destination_type=None,
        destination_name=None,
        grand_total_qty=0,
        grand_total_cost=0,
        grand_total_avg=0,
        contact_details=contact_details,
    )


def get_rawmaterial_transfer_history_range(from_date, to_date, destination_type, destination_name):
    query = """
    SELECT
        rm.name AS raw_material_name,
        rmt.quantity,
        rmt.metric,
        sr.storageroomname AS transferred_from,
        rmt.destination_type,
        CASE
            WHEN rmt.destination_type = 'kitchen' THEN k.kitchenname
            WHEN rmt.destination_type = 'restaurant' THEN r.restaurantname
            ELSE 'Unknown'
        END AS transferred_to,
        rmt.transferred_date,
        rmt.total_cost,
        rmt.transfer_avg
    FROM
        raw_material_transfer_details rmt
    JOIN
        raw_materials rm ON rmt.raw_material_id = rm.id
    JOIN
        storagerooms sr ON rmt.source_storage_room_id = sr.id
    LEFT JOIN
        kitchen k ON rmt.destination_type = 'kitchen' AND rmt.destination_id = k.id
    LEFT JOIN
        restaurant r ON rmt.destination_type = 'restaurant' AND rmt.destination_id = r.id
    WHERE
        DATE(rmt.transferred_date) BETWEEN %s AND %s
        AND rmt.destination_type = %s
        AND rmt.destination_id = %s;
    """
    return fetch_all(query, (from_date, to_date, destination_type, destination_name))

@app.route('/list_prepared_dishes_transfers', methods=["GET", "POST"])
def list_prepared_dishes_transfers():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        selected_date = request.form['transfer_date']
        transfers = get_prepared_dishes_transfer_history(selected_date)
        return render_template('list_prepared_dishes_transfers.html', transfers=transfers, current_date=selected_date, user=session["user"])
    return render_template('list_prepared_dishes_transfers.html', user=session["user"])


@app.route('/profile', methods=['GET', 'POST'])
def profile():
    if "user" not in session:
        return redirect("/login")
    user = get_user_by_email(session["user"]["email"])
    return render_template('profile.html', user=user)


@app.route('/logout')
def logout():
    if "user" not in session:
        return redirect("/login")
    session.pop("user")
    return redirect("/login")


def convert_to_base_unit(quantity, metric):
    """Converts the given quantity to its base unit (grams or ml)."""
    conversions = {
        'kg': 1000,
        'grams': 1,
        'liter': 1000,
        'ml': 1,
        'unit': 1
    }
    return quantity * conversions.get(metric, 1)


def convert_to_original_unit(quantity, metric):
    """Converts the given quantity to its original unit (grams or ml)."""
    conversions = {
        'kg': 1000,
        'grams': 1,
        'liter': 1000,
        'ml': 1,
        'unit': 1
    }
    return quantity // conversions.get(metric, 1)


@app.route('/estimate_dishes', methods=['GET', 'POST'])
def estimate_dishes():
    estimates_data = []
    if request.method == "POST":
        selected_date = request.form.get('date')
        # selected_date = '2024-12-29'

        if not selected_date:
            return jsonify({"error": "Please provide a valid date."}), 400

        try:
            connection = get_db_connection()
            with connection.cursor() as cursor:
                # Query transferred raw materials on the selected date
                transfer_query = """
                    SELECT raw_material_id, raw_material_name, SUM(quantity) as total_quantity, metric
                    FROM raw_material_transfer
                    WHERE transaction_date = %s
                    GROUP BY raw_material_id, raw_material_name, metric
                """
                cursor.execute(transfer_query, (selected_date,))
                transferred_materials = cursor.fetchall()

                if not transferred_materials:
                    return jsonify({"message": "No data available for the selected date."})

                # Convert transferred materials to a dictionary
                material_map = {}
                for material in transferred_materials:
                    material_map[material[0]] = {
                        'name': material[1],
                        'quantity': convert_to_base_unit(material[2], material[3]),
                        'metric': material[3]
                    }

                # Query all dishes and their required raw materials
                dishes_query = """
                    SELECT d.id AS dish_id, d.name AS dish_name, drm.raw_material_id, drm.quantity, drm.metric
                    FROM dishes d
                    JOIN dish_raw_materials drm ON d.id = drm.dish_id
                """
                cursor.execute(dishes_query)
                dish_data = cursor.fetchall()
                # Calculate estimates for each dish
                dish_estimates = {}

                for dish in dish_data:
                    dish_id = dish[0]
                    dish_name = dish[1]
                    raw_material_id = dish[2]

                    # Skip if raw material is not available in the transferred data
                    if raw_material_id not in material_map:
                        continue

                    # Convert required raw material quantity to base unit
                    required_quantity = convert_to_base_unit(dish[3], dish[4])

                    # Calculate max dishes that can be prepared with available material
                    available_quantity = material_map[raw_material_id]['quantity']
                    max_dishes = float(available_quantity) // float(required_quantity)

                    if dish_id not in dish_estimates:
                        dish_estimates[dish_id] = {
                            'name': dish_name,
                            'raw_materials': [],
                            'estimate': max_dishes
                        }
                    else:
                        dish_estimates[dish_id]['estimate'] = min(dish_estimates[dish_id]['estimate'], max_dishes)

                    # Add raw material details
                    dish_estimates[dish_id]['raw_materials'].append({
                        'name': material_map[raw_material_id]['name'],
                        'quantity_used': convert_to_original_unit(available_quantity, material_map[raw_material_id]['metric']),
                        'metric': material_map[raw_material_id]['metric']
                    })

                # Prepare the estimates_data
                estimates_data = []
                for dish_id, details in dish_estimates.items():
                    estimates_data.append({
                        'dish_name': details['name'],
                        'raw_materials': details['raw_materials'],
                        'estimate': details['estimate']
                    })

                return render_template("estimate_dishes.html", user=session["user"], estimates=estimates_data, selected_date=None)

        except Exception as e:
            return jsonify({"error": str(e)}), 500

        finally:
            connection.close()
    return render_template("estimate_dishes.html", user=session["user"], estimates=estimates_data, selected_date=None)


@app.route('/upload_sales_report', methods=['GET', 'POST'])
def upload_sales_report():
    if "user" not in session:
        return redirect("/login")

    if request.method == 'POST':
        file = request.files.get('file')
        restaurant_id = request.form.get("restaurant_id")
        sales_date = request.form.get("sales_report_date")

        if 'file' not in request.files:
            flash('No file part found. Please try again.', "danger")
            return redirect(url_for('upload_sales_report'))

        if file.filename == '':
            flash('No selected file. Please upload a file', "danger")
            return redirect(url_for('upload_sales_report'))

        if file and file.filename.endswith('.xlsx'):
            # Save the file
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
            file.save(file_path)

            # Process the file
            missing_recipes = process_data(file_path)

            if missing_recipes:
                missing_recipes_table = """
                    <table class="table table-bordered">
                        <thead>
                            <tr>
                                <th>Missing Recipe</th>
                            </tr>
                        </thead>
                        <tbody>
                """
                for recipe in missing_recipes:
                    missing_recipes_table += f"<tr><td>{recipe}</td></tr>"
                missing_recipes_table += "</tbody></table>"

                flash(Markup(
                    f"Recipe not found for the following dishes. Kindly update recipe for all the dishes and continue:<br>{missing_recipes_table}"), "danger")
            else:
                # Process the data and update the daily_sales table
                df = pd.read_excel(file_path)
                # Extract sales date from filename format: Restaurant_item_tax_report_YYYY_MM_DD_HH_MM_SS.xlsx
                # filename_parts = file.filename.split('_')
                # sales_date_str = f"{filename_parts[4]}-{filename_parts[5]}-{filename_parts[6]}"
                # sales_date = datetime.strptime(sales_date_str, '%Y-%m-%d').date()

                conn = get_db_connection()
                cursor = conn.cursor()
                sales_report_data = []
                for index, row in df.iterrows():
                    temp = {}
                    temp["category"] = row['Category']
                    temp["item_name"] = row['Item Name']
                    temp["quantity"] = row['Qty']
                    cursor.execute(
                        "SELECT id FROM dishes WHERE category = %s AND name = %s", (temp["category"], temp["item_name"]))
                    dish = cursor.fetchone()
                    if dish:
                        dish_id = dish[0]
                        temp["dish_id"] = dish_id
                        cursor.execute("""
                            INSERT INTO daily_sales (sales_date, dish_id, restaurant_id, quantity)
                            VALUES (%s, %s, %s, %s)
                            ON DUPLICATE KEY UPDATE quantity = quantity + VALUES(quantity)
                        """, (sales_date, dish_id, restaurant_id, temp["quantity"]))
                    else:
                        missing_recipes.append(temp["item_name"])
                    sales_report_data.append(temp)

                conn.commit()
                cursor.close()
                conn.close()

                # Delete the uploaded Excel file
                os.remove(file_path)
                adjust_stocks(sales_report_data, sales_date, restaurant_id)
                flash("Sales report data has been processed succesfully and the inventory stocks have been adjusted accordingly. Please do not reupload the sales report as it will modify the inventory.", "success")
            return redirect(url_for('upload_sales_report'))

    restaurants = get_all_restaurants(only_active=True)
    return render_template('upload_sales_report.html', user=session["user"], restaurants=restaurants, current_date=get_current_date())


@app.route('/get_available_quantity', methods=['GET'])
def get_available_quantity():
    storageroom_id = int(request.args.get('storageroom_id'))
    raw_material_id = request.args.get('raw_material_id')
    available_quantity = get_storageroom_rawmaterial_quantity(storageroom_id, raw_material_id)
    avg_cost  = get_average_cost_from_inventory_by_raw_material_id(raw_material_id, storageroom_id)
    
    print(f"average_cost '{avg_cost}'")

    average_cost = (
        float(avg_cost["average_unit_cost"])
        if avg_cost and avg_cost.get("average_unit_cost") is not None
        else 0.0
    )

    storage_available_quantity = 0
    if available_quantity:
        storage_available_quantity = available_quantity[0]["quantity"]
    # # Check if storage room and raw material exist
    # available_quantity = storage_available_quantity.get(raw_material_id, 0)

    data = {"available_quantity": float(storage_available_quantity) ,  "avg_cost" : average_cost }
    return jsonify(data)


@app.route('/add_prepared_dishes', methods=['GET', 'POST'])
def add_prepared_dishes():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        # try:
        # Retrieve form data
        dish_categories = request.form.getlist('dish_categories[]')
        dish_names = request.form.getlist('dish_names[]')
        prepared_quantities = request.form.getlist('prepared_quantities[]')
        prepared_in_kitchen = request.form.get('kitchen_id')
        prepared_on = request.form.get('prepared_on')

        for category, dish, quantity in zip(dish_categories, dish_names, prepared_quantities):
            quantity = Decimal(quantity)
            # Validate dish existence
            dish_query = """
                SELECT id FROM dishes 
                WHERE category = %s AND name = %s
            """
            dish_data = fetch_one(dish_query, (category, dish))
            if not dish_data:
                flash(f"Dish '{dish}' under category '{category}' does not exist. Please add the dish.", "error")
                return redirect(request.url)
            dish_id = dish_data['id']

            # Check if the dish exists for the given kitchen and date
            existing_record = fetch_one(
                """
                SELECT id FROM kitchen_prepared_dishes 
                WHERE prepared_dish_id = %s AND prepared_in_kitchen = %s AND prepared_on = %s
                """,
                (dish_id, prepared_in_kitchen, prepared_on)
            )

            if existing_record:
                # Update quantity if record exists
                execute_query(
                    """
                    UPDATE kitchen_prepared_dishes 
                    SET prepared_quantity = prepared_quantity + %s, 
                        available_quantity = available_quantity + %s 
                    WHERE id = %s
                    """,
                    (quantity, quantity, existing_record['id'])
                )
            else:
                # Insert new record
                execute_query(
                    """
                    INSERT INTO kitchen_prepared_dishes 
                    (prepared_dish_id, prepared_quantity, available_quantity, prepared_in_kitchen, prepared_on) 
                    VALUES (%s, %s, %s, %s, %s)
                    """,
                    (dish_id, quantity, quantity, prepared_in_kitchen, prepared_on)
                )

            # Update kitchen stock
            update_kitchen_stock(prepared_in_kitchen, dish_id, quantity, prepared_on)

        flash("Prepared dishes added successfully!", "success")
        return redirect('/add_prepared_dishes')

        # except Exception as e:
        #     app.logger.error(f"Error while adding prepared dishes: {e}")
        #     flash("An error occurred while adding prepared dishes.", "error")
        #     return redirect(request.url)

    # GET request: fetch data for rendering the page
    dish_categories = get_unique_dish_categories()
    dishes = get_all_dishes()
    kitchens = get_all_kitchens(only_active=True)

    # Organize dishes by category
    dish_mapping = {}
    for dish in dishes:
        dish_mapping.setdefault(dish['category'], []).append(dish['name'])

    return render_template(
        'add_prepared_dishes.html',
        dish_categories=dish_categories,
        dish_mapping=dish_mapping,
        kitchens=kitchens,
        user=session["user"],
        todays_date=get_current_date()
    )


@app.route('/list_prepared_dishes', methods=['GET', 'POST'])
def list_prepared_dishes():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':
        prepared_date = request.form['prepared_date']
        prepared_dishes = get_all_prepared_dishes(prepared_date)
        return render_template('list_prepared_dishes.html', user=session["user"], prepared_dishes=prepared_dishes, current_date=prepared_date)
    return render_template('list_prepared_dishes.html', user=session["user"])


@app.route('/userlist', methods=['GET', 'POST'])
def userlist():
    if "user" not in session:
        return redirect("/login")
    users = get_all_users()

    return render_template('userlist.html', user=session["user"], users=users)


@app.route('/transfer_prepared_dishes', methods=['GET', 'POST'])
def transfer_prepared_dishes():
    if "user" not in session:
        return redirect("/login")

    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    # Fetch dishes, restaurants, and kitchens to populate in the form
    prepared_dishes_today = get_prepared_dishes_today()
    dish_categories = list(set([dish["prepared_dish_category"] for dish in prepared_dishes_today]))
    kitchens = get_all_kitchens(only_active=True)
    restaurants = get_all_restaurants(only_active=True)

    current_date = get_current_date()

    # Handle form submission for dish transfer
    if request.method == 'POST':
        source_kitchen_id = request.form['kitchen']

        destination_restaurant_id = request.form['destination_name']

        dish_categories = request.form.getlist('dish_categories[]')

        dish_names = request.form.getlist('dish_names[]')

        transferred_quantities = request.form.getlist('transferred_quantities[]')

        transfer_date = request.form['transfer_date']

        # try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # Insert the transfer details into the database
        for category, name, quantity in zip(dish_categories, dish_names, transferred_quantities):
            dish_id = get_dish_details_from_category(category, name)[0]["id"]
            cursor.execute(
                """
                SELECT available_quantity FROM kitchen_prepared_dishes
                WHERE prepared_dish_id=%s AND prepared_in_kitchen = %s AND prepared_on=%s
                """,
                (dish_id, source_kitchen_id, transfer_date)
            )
            dish = cursor.fetchone()

            if dish and dish[0] >= int(quantity):
                cursor.execute("""
                INSERT INTO prepared_dish_transfer (
                    source_kitchen_id,
                    destination_restaurant_id,
                    dish_id,
                    quantity,
                    transferred_date
                ) VALUES (%s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE 
                    quantity = quantity + VALUES(quantity);
                """, (source_kitchen_id, destination_restaurant_id, dish_id, quantity, transfer_date))

                # Update the available quantity in the source kitchen
                cursor.execute(
                    """
                    UPDATE kitchen_prepared_dishes
                    SET available_quantity = available_quantity - %s
                    WHERE prepared_dish_id=%s AND prepared_in_kitchen = %s AND prepared_on=%s
                    """,
                    (quantity, dish_id, source_kitchen_id, transfer_date)
                )
                conn.commit()
            else:
                flash(f"Insufficient quantity for dish: {name} in category: {category}", "danger")
                conn.rollback()
                cursor.close()
                conn.close()
                return redirect(url_for('transfer_prepared_dishes'))

        flash("Dish transfer successful!", "success")

        # except Exception as e:
        #     conn.rollback()  # Rollback in case of any error
        #     app.logger.error(f"Error during dish transfer: {e}")
        #     flash("Error occurred while transferring the dish.", "danger")
        # finally:
        #     cursor.close()
        #     conn.close()

        return redirect(url_for('transfer_prepared_dishes'))

    return render_template('transfer_prepared_dishes.html', dish_categories=dish_categories, current_date=current_date, prepared_dishes_today=prepared_dishes_today, restaurants=restaurants, kitchens=kitchens, user=session["user"])


@app.route('/check_dish_availability', methods=['GET', 'POST'])
def check_dish_availability():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':
        selected_date = request.form['selected_date']
        restaurant_id = request.form['restaurant_id']

        # Establish DB connection
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        # Query to get dish details for the selected restaurant and date
        query = """
        SELECT d.name, d.category, SUM(pdt.quantity) AS quantity_available
        FROM prepared_dish_transfer pdt
        JOIN dishes d ON pdt.dish_id = d.id
        WHERE pdt.destination_restaurant_id = %s
        AND pdt.transferred_date = %s
        GROUP BY pdt.dish_id
        """
        cursor.execute(query, (restaurant_id, selected_date))
        dishes = cursor.fetchall()

        cursor.close()
        conn.close()

        # Render the page with the fetched data
        return render_template('check_dish_availability.html', dishes=dishes, restaurants=get_restaurants(), user=session["user"])

    # Fetch restaurants to show in the dropdown
    return render_template('check_dish_availability.html', restaurants=get_restaurants(), user=session["user"])

# Function to fetch restaurant data for the dropdown


def get_restaurants():
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    cursor.execute("SELECT id, restaurantname, restaurantcode FROM restaurant")
    restaurants = cursor.fetchall()
    cursor.close()
    conn.close()
    return restaurants


# Read the Excel file
def read_excel(file_path):
    return pd.read_excel(file_path)


def process_data(file_path):

    data = read_excel(file_path)
    missing_recipes = []

    for index, row in data.iterrows():
        category = row['Category']
        item_name = row['Item Name']
        # Find dish_id
        dish = get_dish_details_from_category(category, item_name)

        if dish:
            dish_id = dish[0]["id"]
            dish_recipe = get_dish_recipe(dish_id)
            if not dish_recipe:
                missing_recipes.append(f"{category} - {item_name}")
        else:
            missing_recipes.append(f"{category} - {item_name}")
    return missing_recipes


def adjust_stocks(sales_report_data, report_date, restaurant_id):
    conn = get_db_connection()
    if not conn:
        print("Failed to connect to the database.")
        return []

    # data = get_sales_report_data(report_date)
    for dish_data in sales_report_data:

        dish_recipe = get_dish_recipe(dish_data["dish_id"])

        transferred_dish = check_dish_transferred(dish_data["dish_id"], report_date, restaurant_id)
        if transferred_dish:
            pass
        else:
            update_restaurant_stock(restaurant_id, dish_data["dish_id"], dish_data["quantity"], report_date)
        #     materials = get_raw_materials(dish_data["dish_id"])
        #     raw_materials = []
        #     for material in materials:
        #         raw_materials.append({
        #             'raw_material_id': material[0],
        #             'quantity': material[1] * dish_data["quantity"],
        #             'metric': material[2]
        #         })
        #     subtract_raw_materials(raw_materials, "restaurant", restaurant_id, report_date)
        # # transferred_dish = check_dish_transferred(dish_data["id"], report_date, restaurant_id)
        # # if transferred_dish:
        # #     pass
        # #     # subtract_raw_materials(raw_materials, "kitchen", transferred_dish[0], report_date)

        # else:
        #     subtract_raw_materials(raw_materials, "restaurant", restaurant_id, report_date)


@app.route('/restaurant_consumption', methods=['GET', 'POST'])
def restaurant_consumption():
    if "user" not in session:
        return redirect("/login")
    restaurants = get_all_restaurants(only_active=True)
    if request.method == 'POST':
        selected_date = request.form['report_date']
        restaurant_id = request.form['restaurant_id']
        consumption_data = get_restaurant_consumption_report(restaurant_id, selected_date)
        return render_template("restaurant_consumption.html", user=session["user"], restaurants=restaurants, current_date=selected_date, query_result=consumption_data)
    return render_template("restaurant_consumption.html", user=session["user"], restaurants=restaurants, current_date=get_current_date())


@app.route('/kitchen_consumption', methods=['GET', 'POST'])
def kitchen_consumption():
    if "user" not in session:
        return redirect("/login")
    kitchens = get_all_kitchens(only_active=True)
    if request.method == 'POST':
        selected_date = request.form['report_date']
        kitchen_id = request.form['kitchen_id']
        consumption_data = get_kitchen_consumption_report(kitchen_id, selected_date)
        return render_template("kitchen_consumption.html", user=session["user"], kitchens=kitchens, current_date=selected_date, query_result=consumption_data)
    return render_template("kitchen_consumption.html", user=session["user"], kitchens=kitchens, current_date=get_current_date())


@app.route("/api/purchase_trend")
def purchase_trend():
    year = request.args.get("year", type=int)
    month = request.args.get("month", type=int)
    from_date = request.args.get("from")
    to_date = request.args.get("to")

    connection = get_db_connection()
    cursor = connection.cursor()

    if year and not month: 
        # ‚úÖ Yearly aggregation
        query = """
            SELECT MONTH(purchase_date) AS month, SUM(total_cost) AS purchase_amount
            FROM purchase_history
            WHERE YEAR(purchase_date) = %s
            GROUP BY MONTH(purchase_date)
            ORDER BY MONTH(purchase_date);
        """
        cursor.execute(query, (year,))
        result = cursor.fetchall()

        months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        purchase_data = {row[0]: row[1] for row in result}
        purchase_amounts = [purchase_data.get(i+1, 0) for i in range(12)]

        response = {"type": "yearly", "year": year, "months": months, "purchase_amounts": purchase_amounts}

    elif year and month: 
        # ‚úÖ Monthly aggregation (day wise)
        query = """
            SELECT DAY(purchase_date) AS day, SUM(total_cost) AS purchase_amount
            FROM purchase_history
            WHERE YEAR(purchase_date) = %s AND MONTH(purchase_date) = %s
            GROUP BY DAY(purchase_date)
            ORDER BY DAY(purchase_date);
        """
        cursor.execute(query, (year, month))
        result = cursor.fetchall()

        days = [str(row[0]) for row in result]
        amounts = [row[1] for row in result]

        response = {"type": "monthly", "year": year, "month": month, "days": days, "purchase_amounts": amounts}

    elif from_date and to_date: 
        # ‚úÖ Custom date range
        query = """
            SELECT DATE(purchase_date) AS date, SUM(total_cost) AS purchase_amount
            FROM purchase_history
            WHERE purchase_date BETWEEN %s AND %s
            GROUP BY DATE(purchase_date)
            ORDER BY DATE(purchase_date);
        """
        cursor.execute(query, (from_date, to_date))
        result = cursor.fetchall()

        dates = [str(row[0]) for row in result]
        amounts = [row[1] for row in result]

        response = {"type": "custom", "from": from_date, "to": to_date, "dates": dates, "purchase_amounts": amounts}

    else:
        response = {"error": "Please provide either year, year+month, or from+to dates."}

    cursor.close()
    connection.close()
    return jsonify(response)
    # return {
    #     "year": 2025,
    #     "months": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    #     "purchase_amounts": [12000, 15000, 18000, 11000, 9000, 20000, 25000, 23000, 17000, 19000, 22000, 24000]
    # }


@app.route('/stock_report', methods=["GET", "POST"])
def stock_report():
    if "user" not in session:
        return redirect("/login")
    # if request.method == "POST":
    #     selected_date = request.form['transfer_date']
    #     transfers = get_prepared_dishes_transfer_history(selected_date)
    #     return render_template('stock_report.html', transfers=transfers, current_date=selected_date, user=session["user"])
    rm_categories = get_rawmaterial_category()
    rm_categories = [rmc[0] for rmc in rm_categories]
    contact_details = get_contact_details()
    return render_template('stock_report.html', user=session["user"], storage_rooms=get_all_storagerooms(only_active=True),
                           restaurants=get_all_restaurants(only_active=True),
                           kitchens=get_all_kitchens(only_active=True), rawmaterial_category=rm_categories, contact_details=contact_details)


@app.route('/transfer_raw_material_report', methods=["GET", "POST"])
def transfer_raw_material_report():
    if "user" not in session:
        return redirect("/login")
    contact_details = get_contact_details()
    return render_template('transfer_raw_material_report.html', user=session["user"], storage_rooms=get_all_storagerooms(only_active=True),
                           restaurants=get_all_restaurants(only_active=True),
                           kitchens=get_all_kitchens(only_active=True), contact_details=contact_details)


@app.route('/get_transfer_details_report', methods=["GET"])
def get_transfer_details():
    if "user" not in session:
        return redirect("/login")

    # Fetch query parameters from request
    storageroom_id = request.args.get("storageroom")
    destination_type = request.args.get("destination_type")
    destination_id = request.args.get("destination_name")
    transfer_date = request.args.get("transfer_date")
    transfer_id = request.args.get("transfer_id")

    if not destination_type or not destination_id or not storageroom_id or not transfer_date or not transfer_id:
        return jsonify({"error": "Missing required parameters"}), 400

    # Fetch raw material transfer details
    rm = get_transfer_raw_material_report(storageroom_id, destination_type, destination_id, transfer_date, transfer_id)

    return jsonify(rm)  # Return as JSON response


@app.route("/contact_details", methods=["GET", "POST"])
def contact_details():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        name = request.form["name"].strip()
        contact_number = request.form["contact_number"].strip()
        address = request.form["address"].strip()

        insert_query = """
            INSERT INTO contact_details (name, contact_number, address)
            VALUES (%s, %s, %s)
        """
        if execute_query(insert_query, (name, contact_number, address)):
            flash("Details added successfully!", "success")
        else:
            flash("Error: Unable to add the details. Please try again later.", "danger")
        return redirect("/contact_details")
    contact_details = get_contact_details()
    return render_template("contact_details.html", user=session["user"], contact_details=contact_details)


@app.route('/deleteuser/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    if "user" not in session:
        return redirect("/login")
    if delete_user_from_db(user_id):
        flash("User deleted successfully!", "success")
        return jsonify({"success": True}), 200
    else:
        flash("Error: Unable to delete the user!", "danger")
        return jsonify({"success": False, "message": "User not found"}), 404


@app.route('/deleterawmaterial/<int:rawmaterial_id>', methods=['DELETE'])
def delete_rawmaterial(rawmaterial_id):
    if "user" not in session:
        return redirect("/login")
    if delete_rawmaterial_from_db(rawmaterial_id):
        flash("Rawmaterial deleted successfully!", "success")
        return jsonify({"success": True}), 200
    else:
        flash("Error: Unable to delete the rawmaterial!", "danger")
        return jsonify({"success": False, "message": "Unable to delete the rawmaterial"}), 404


@app.route('/get_transfer_ids', methods=['GET'])
def get_transfer_ids():
    transfer_ids_list = []
    storageroom_id = request.args.get('storageroom')
    destination_type = request.args.get('destination_type')
    destination_name = request.args.get('destination_name')
    transfer_date = request.args.get('transfer_date')

    if not storageroom_id or not destination_type or not destination_name or not transfer_date:
        return jsonify([])  # Return an empty list if any field is missing

    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        query = """
        SELECT DISTINCT transfer_id FROM raw_material_transfer_details
        WHERE source_storage_room_id = %s 
        AND destination_type = %s 
        AND destination_id = %s
        AND DATE(transferred_date) = %s
        ORDER BY transfer_id ASC
        """
        cursor.execute(query, (storageroom_id, destination_type, destination_name, transfer_date))
        transfer_ids = cursor.fetchall()

        conn.close()

        # Add "All" and "Total" options
        if transfer_ids:
            transfer_ids_list = [{"transfer_id": "all"}, {"transfer_id": "total"}]
            transfer_ids_list += [{"transfer_id": row[0]} for row in transfer_ids]

        return jsonify(transfer_ids_list)

    except Exception as e:
        app.logger.error(f"Error fetching transfer IDs: {e}")
        return jsonify({"error": "Internal Server Error"}), 500


@app.route("/delete_purchase_record", methods=["GET", "POST"])
def delete_purchase_record():
    if "user" not in session:
        return redirect("/login")
    today_date = get_current_date()
    # today_date = '2025-03-25'
    todays_purchase = get_cumulative_purchase_record_invoice_wise(today_date)
    return render_template("delete_purchase_record.html", user=session["user"], today_date=today_date, todays_purchase=todays_purchase)


@app.route("/delete_purchase_and_adjust_stock", methods=["DELETE"])
def delete_purchase_and_adjust_stock():
    data = request.get_json()
    vendor_id = data.get("vendor_id")
    invoice_number = data.get("invoice_number")
    storageroom_id = data.get("storageroom_id")
    purchase_date = data.get("purchase_date")

    if not all([vendor_id, invoice_number, storageroom_id, purchase_date]):
        flash("Missing required parameters", "danger")
        return jsonify({"success": False, "message": "Missing required parameters"}), 400

    conn = get_db_connection()
    cursor = conn.cursor()

    try:
        # Fetch all raw materials associated with the purchase
        cursor.execute("""
            SELECT raw_material_id, quantity 
            FROM purchase_history 
            WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
        """, (vendor_id, invoice_number, purchase_date))

        purchase_records = cursor.fetchall()

        if not purchase_records:
            return jsonify({"success": False, "message": "No matching purchase records found"}), 404

        # Adjust inventory_stock for each raw material
        for record in purchase_records:
            raw_material_id = record[0]
            quantity = record[1]

            cursor.execute("""
                UPDATE inventory_stock 
                SET incoming_stock = incoming_stock - %s, 
                    currently_available = currently_available - %s 
                WHERE raw_material_id = %s AND destination_type = 'storageroom' AND destination_id = %s
            """, (quantity, quantity, raw_material_id, storageroom_id))
        # Delete purchase records after stock adjustment
        cursor.execute("""
            DELETE FROM purchase_history 
            WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
        """, (vendor_id, invoice_number, purchase_date))

        # Delete associated payment records
        cursor.execute("""
            DELETE FROM vendor_payment_tracker
            WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
        """, (vendor_id, invoice_number, purchase_date))

        cursor.execute("""
            DELETE FROM payment_records
            WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
        """, (vendor_id, invoice_number, purchase_date))
        conn.commit()  # Commit the transaction only if everything is successful
        flash("Purchase deleted and stock adjusted successfully!", "success")
        return jsonify({"success": True, "message": "Purchase deleted and stock adjusted."})

    except Exception as e:
        conn.rollback()  # Rollback in case of an error
        app.logger.error(f"Failed to delete purchase record {str(e)}")
        flash("Failed to delete purchase record", "danger")
        return jsonify({"success": False, "message": f"Error: {str(e)}"}), 500

    finally:
        cursor.close()
        conn.close()

from flask import render_template, request, redirect, session, flash, url_for
from datetime import date, datetime
import pytz

@app.route('/fetch-misc-expense', methods=['GET'])
def fetch_misc_expense():
    if "user" not in session:
        return jsonify({"error": "Unauthorized"}), 401

    restaurant_id = request.args.get("restaurant_id")
    report_date = request.args.get("report_date")

    if not restaurant_id or not report_date:
        return jsonify({"total_misc": 0})

    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    # Use COALESCE(manual_date, created_at) so that manual_date takes priority
    cursor.execute("""
        SELECT COALESCE(SUM(cost),0) AS total_misc
        FROM miscellaneous_items
        WHERE restaurant_id = %s
          AND DATE(COALESCE(manual_date, created_at)) = %s
          AND status = 'active'
    """, (restaurant_id, report_date))

    result = cursor.fetchone()
    cursor.close()
    conn.close()

    return jsonify({"total_misc": float(result['total_misc'] or 0)})

@app.route('/fetch-prebooking-paid-today', methods=['GET'])
def fetch_prebooking_paid_today():
    if "user" not in session:
        return jsonify({"error": "Unauthorized"}), 401

    restaurant_id = request.args.get("restaurant_id")
    report_date = request.args.get("report_date")  # YYYY-MM-DD

    if not restaurant_id or not report_date:
        return jsonify({"total_prebooking_paid": 0})

    try:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        # CORRECT QUERY: Sum from prebooking_payments table (not prebooking_orders)
        cursor.execute("""
            SELECT COALESCE(SUM(amount), 0) AS total_prebooking_paid
            FROM prebooking_payments pp
            INNER JOIN prebooking_orders po ON pp.order_id = po.id
            WHERE po.restaurant_id = %s
              AND DATE(pp.payment_date) = %s
              AND po.is_deleted = 0
        """, (restaurant_id, report_date))

        result = cursor.fetchone()
        total = float(result['total_prebooking_paid'])

        cursor.close()
        conn.close()
        return jsonify({"total_prebooking_paid": total})

    except Exception as e:
        print("Error in fetch-prebooking-paid-today:", e)
        return jsonify({"total_prebooking_paid": 0})

@app.route('/add-nbs-report', methods=['GET', 'POST'])
def add_nbs_report():
    if "user" not in session:
        return redirect("/login")

    user = session["user"]
    email = user.get("email")

    selected_restaurant_id = None
    disable_restaurant_dropdown = False

    # Email ‚Üí branch mapping for branch managers
    if email == "bmktcnagar@gmail.com":
        selected_restaurant_id = 1
        disable_restaurant_dropdown = True
    elif email == "bmnewbs@gmail.com":
        selected_restaurant_id = 2
        disable_restaurant_dropdown = True
    elif email == "dharanistorekeeper@gmail.com":
        selected_restaurant_id = 4
        disable_restaurant_dropdown = True

    # Fetch all active restaurants
    restaurants = fetch_all("SELECT id, restaurantname FROM restaurant WHERE status='active'")

    today = date.today()

    # GET request - calculate prefilled misc expense
    r_expense_prefill = 0
    if selected_restaurant_id:
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        cursor.execute("""
            SELECT COALESCE(SUM(cost),0) AS total_misc
            FROM miscellaneous_items
            WHERE restaurant_id=%s AND DATE(created_at)=%s AND status='active'
        """, (selected_restaurant_id, today))
        result = cursor.fetchone()
        r_expense_prefill = float(result['total_misc'] or 0)
        cursor.close()
        conn.close()

    if request.method == 'POST':
        try:
            report_date = request.form['report_date']
            restaurant_id = request.form.get('restaurant_id')
            if disable_restaurant_dropdown and selected_restaurant_id:
                restaurant_id = selected_restaurant_id
            restaurant_id = int(restaurant_id)

            # Income fields
            petpooja_total = float(request.form.get('petpooja_total') or 0)
            ns_total = float(request.form.get('ns_total') or 0)
            outdoor_catering = float(request.form.get('outdoor_catering') or 0)

            # Payment methods
            upi = float(request.form.get('upi') or 0)
            cash = float(request.form.get('cash') or 0)
            r_expense = float(request.form.get('r_expense') or 0)

            # Online platforms
            swiggy = float(request.form.get('swiggy') or 0)
            zomato = float(request.form.get('zomato') or 0)

            # Derived fields
            total_income = petpooja_total + ns_total + outdoor_catering
            net_sales = total_income
            net_counter = upi + cash + r_expense + swiggy + zomato
            difference = net_counter - net_sales

            conn = get_db_connection()
            cursor = conn.cursor()

            # Check existing report
            cursor.execute("""
                SELECT id FROM nbs_daily_reports 
                WHERE report_date=%s AND restaurant_id=%s
            """, (report_date, restaurant_id))
            existing_report = cursor.fetchone()

            if existing_report:
                cursor.execute("""
                    UPDATE nbs_daily_reports SET
                    petpooja_total=%s, ns_total=%s, outdoor_catering=%s,
                    total_income=%s, upi=%s, cash=%s, r_expense=%s,
                    swiggy=%s, zomato=%s, net_counter=%s, net_sales=%s, difference=%s,
                    updated_at=CURRENT_TIMESTAMP
                    WHERE report_date=%s AND restaurant_id=%s
                """, (
                    petpooja_total, ns_total, outdoor_catering, total_income,
                    upi, cash, r_expense, swiggy, zomato, net_counter, net_sales,
                    difference, report_date, restaurant_id
                ))
                message = "Report updated successfully!"
            else:
                cursor.execute("""
                    INSERT INTO nbs_daily_reports (
                    report_date, restaurant_id, petpooja_total, ns_total,
                    outdoor_catering, total_income, upi, cash, r_expense,
                    swiggy, zomato, net_counter, net_sales, difference
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    report_date, restaurant_id, petpooja_total, ns_total,
                    outdoor_catering, total_income, upi, cash, r_expense,
                    swiggy, zomato, net_counter, net_sales, difference
                ))
                message = "Report added successfully!"

            conn.commit()
            cursor.close()
            conn.close()

            flash(message, 'success')
            return redirect(url_for('nbs_reports'))

        except Exception as e:
            flash(f"Error: {str(e)}", 'danger')
            return redirect(url_for('add_nbs_report'))

    # GET request - render form
    return render_template(
        'add_nbs_report.html',
        user=user,
        restaurants=restaurants,
        selected_restaurant_id=selected_restaurant_id,
        disable_restaurant_dropdown=disable_restaurant_dropdown,
        today=today,
        r_expense_prefill=r_expense_prefill
    )

@app.route('/edit-nbs-report/<int:report_id>', methods=['GET', 'POST'])
def edit_nbs_report(report_id):
    if "user" not in session:
        return redirect("/login")
    
    user = session["user"]
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    # Fetch all active restaurants
    cursor.execute("SELECT id, restaurantname FROM restaurant WHERE status='active'")
    restaurants = cursor.fetchall()

    if request.method == 'POST':
        try:
            report_date = request.form['report_date']
            restaurant_id = request.form['restaurant_id']

            # Income fields
            petpooja_total = float(request.form['petpooja_total'] or 0)
            ns_total = float(request.form['ns_total'] or 0)
            outdoor_catering = float(request.form['outdoor_catering'] or 0)

            # Payment methods
            upi = float(request.form['upi'] or 0)
            cash = float(request.form['cash'] or 0)
            r_expense = float(request.form['r_expense'] or 0)

            # Online platforms
            swiggy = float(request.form['swiggy'] or 0)
            zomato = float(request.form['zomato'] or 0)

            # NEW CALCULATION (matching view_nbs_report logic)
            total_income = petpooja_total + ns_total + outdoor_catering
            net_sales = total_income  # Removed swiggy + zomato
            net_counter = upi + cash + r_expense + swiggy + zomato  # Added swiggy + zomato
            difference = net_counter - net_sales

            cursor.execute("""
                UPDATE nbs_daily_reports SET
                    report_date=%s,
                    restaurant_id=%s,
                    petpooja_total=%s,
                    ns_total=%s,
                    outdoor_catering=%s,
                    total_income=%s,
                    upi=%s,
                    cash=%s,
                    r_expense=%s,
                    swiggy=%s,
                    zomato=%s,
                    net_counter=%s,
                    net_sales=%s,
                    difference=%s,
                    updated_at=CURRENT_TIMESTAMP
                WHERE id=%s
            """, (
                report_date, restaurant_id, petpooja_total, ns_total, outdoor_catering,
                total_income, upi, cash, r_expense, swiggy, zomato, net_counter,
                net_sales, difference, report_id
            ))

            conn.commit()
            flash("Report updated successfully!", "success")
            return redirect(url_for("nbs_reports"))

        except Exception as e:
            flash(f"Error: {str(e)}", "error")
            return redirect(url_for("edit_nbs_report", report_id=report_id))

    # GET request - fetch report
    cursor.execute("SELECT * FROM nbs_daily_reports WHERE id=%s", (report_id,))
    report = cursor.fetchone()

    # Map restaurant_id to name for display
    if report:
        restaurant_name = next((r['restaurantname'] for r in restaurants if r['id'] == report['restaurant_id']), None)
        report['restaurant_name'] = restaurant_name

        # NEW CALCULATION (matching view_nbs_report logic)
        petpooja = float(report.get('petpooja_total', 0) or 0)
        ns = float(report.get('ns_total', 0) or 0)
        outdoor = float(report.get('outdoor_catering', 0) or 0)
        swiggy = float(report.get('swiggy', 0) or 0)
        zomato = float(report.get('zomato', 0) or 0)
        upi = float(report.get('upi', 0) or 0)
        cash = float(report.get('cash', 0) or 0)
        r_expense = float(report.get('r_expense', 0) or 0)

        total_income = petpooja + ns + outdoor
        net_sales = total_income  # Removed swiggy + zomato
        net_counter = upi + cash + r_expense + swiggy + zomato  # Added swiggy + zomato
        difference = net_counter - net_sales

        report['net_sales'] = net_sales
        report['net_counter'] = net_counter
        report['difference'] = difference

    cursor.close()
    conn.close()

    return render_template(
        'edit_nbs_report.html',
        report=report,
        user=user,
        restaurants=restaurants,
        selected_restaurant_id=report['restaurant_id']
    )

@app.route('/nbs-reports', methods=['GET', 'POST'])
def nbs_reports():
    if "user" not in session:
        return redirect("/login")

    user = session["user"]
    role = user["role"]
    email = user.get("email")

    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    # --- Pagination Setup ---
    per_page = 40
    page = int(request.args.get("page", 1))
    offset = (page - 1) * per_page

    # --- Restaurant Dropdown ---
    cursor.execute("SELECT id, restaurantname FROM restaurant ORDER BY restaurantname")
    restaurants = cursor.fetchall()

    # --- Filters ---
    restaurant_id = request.args.get("restaurant_id")
    start_date = request.args.get("start_date")
    end_date = request.args.get("end_date")

    # --- Base Query ---
    base_query = """
        FROM nbs_daily_reports n
        LEFT JOIN restaurant r ON n.restaurant_id = r.id
        WHERE 1=1
    """
    params = []

    # --- ROLE-BASED ACCESS ---
    if role in ["admin", "store_manager"]:
        if restaurant_id and restaurant_id.isdigit():
            base_query += " AND n.restaurant_id = %s"
            params.append(restaurant_id)
    elif role == "branch_manager":
        email_to_restaurant = {
            "bmktcnagar@gmail.com": 1,
            "bmnewbs@gmail.com": 2,
            "dharanistorekeeper@gmail.com": 4
        }
        fixed_restaurant_id = email_to_restaurant.get(email)
        if fixed_restaurant_id:
            base_query += " AND n.restaurant_id = %s"
            params.append(fixed_restaurant_id)
            restaurant_id = str(fixed_restaurant_id)

    # --- Date Filters ---
    if start_date and end_date:
        base_query += " AND n.report_date BETWEEN %s AND %s"
        params.extend([start_date, end_date])
    elif start_date:
        base_query += " AND n.report_date >= %s"
        params.append(start_date)
    elif end_date:
        base_query += " AND n.report_date <= %s"
        params.append(end_date)

    # --- Total Records Count ---
    cursor.execute(f"SELECT COUNT(*) as total {base_query}", params)
    total_records = cursor.fetchone()["total"]
    total_pages = (total_records + per_page - 1) // per_page

    # --- Fetch Paginated Reports ---
    query = f"""
        SELECT n.*, r.restaurantname
        {base_query}
        ORDER BY n.report_date DESC
        LIMIT %s OFFSET %s
    """
    cursor.execute(query, (*params, per_page, offset))
    reports = cursor.fetchall() or []

    # --- Totals ---
    total_income_sum = total_net_counter_sum = total_net_sales_sum = total_difference_sum = 0.0
    total_swiggy_sum = total_zomato_sum = 0.0

    for report in reports:
        pet = float(report.get('petpooja_total') or 0)
        ns = float(report.get('ns_total') or 0)
        outdoor = float(report.get('outdoor_catering') or 0)
        swiggy = float(report.get('swiggy') or 0)
        zomato = float(report.get('zomato') or 0)
        upi = float(report.get('upi') or 0)
        cash = float(report.get('cash') or 0)
        r_expense = float(report.get('r_expense') or 0)
        
        # NEW CALCULATION
        total_income = pet + ns + outdoor
        net_sales = total_income
        net_counter = upi + cash + r_expense + swiggy + zomato
        difference = net_counter - net_sales

        report['total_income'] = total_income
        report['net_petpooja'] = net_sales
        report['net_counter'] = net_counter
        report['difference'] = difference

        total_income_sum += total_income
        total_net_counter_sum += net_counter
        total_net_sales_sum += net_sales
        total_difference_sum += difference
        total_swiggy_sum += swiggy
        total_zomato_sum += zomato

    cursor.close()
    conn.close()

    totals = {
        'total_income': total_income_sum,
        'net_counter': total_net_counter_sum,
        'net_sales': total_net_sales_sum,
        'difference': total_difference_sum,
        'total_swiggy': total_swiggy_sum,
        'total_zomato': total_zomato_sum
    }

    return render_template(
        'nbs_reports.html',
        reports=reports,
        user=user,
        totals=totals,
        restaurants=restaurants,
        selected_restaurant=restaurant_id,
        start_date=start_date,
        end_date=end_date,
        page=page,
        total_pages=total_pages
    )


@app.route('/view-nbs-report/<int:report_id>')
def view_nbs_report(report_id):
    if "user" not in session:
        return redirect("/login")
    
    user = session["user"]

    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    
    cursor.execute("SELECT * FROM nbs_daily_reports WHERE id = %s", (report_id,))
    report = cursor.fetchone()
    
    if not report:
        cursor.close()
        conn.close()
        flash('Report not found!', 'error')
        return redirect(url_for('nbs_reports'))

    # Set cashier name from branch if empty
    if not report.get('cashier_name'):
        cursor.execute("SELECT restaurantname FROM restaurant WHERE id=%s", (report['restaurant_id'],))
        branch = cursor.fetchone()
        report['cashier_name'] = branch['restaurantname'] if branch else 'Unknown Branch'

    # Recalculate live values
    petpooja = float(report.get('petpooja_total') or 0)
    ns = float(report.get('ns_total') or 0)
    outdoor = float(report.get('outdoor_catering') or 0)
    swiggy = float(report.get('swiggy') or 0)
    zomato = float(report.get('zomato') or 0)
    upi = float(report.get('upi') or 0)
    cash = float(report.get('cash') or 0)
    r_expense = float(report.get('r_expense') or 0)

    total_income = petpooja + ns + outdoor
    net_sales = total_income
    net_counter = upi + cash + r_expense + swiggy + zomato
    difference = net_counter - net_sales

    report['total_income'] = total_income
    report['net_petpooja'] = net_sales
    report['net_counter'] = net_counter
    report['difference'] = difference

    cursor.close()
    conn.close()
    
    return render_template('view_nbs_report.html', report=report, user=user)

@app.route('/delete-nbs-report/<int:report_id>')
def delete_nbs_report(report_id):
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM nbs_daily_reports WHERE id = %s", (report_id,))
        conn.commit()
        
        cursor.close()
        conn.close()
        
        flash('Report deleted successfully!', 'success')
    except Exception as e:
        flash(f'Error: {str(e)}', 'error')
    
    return redirect(url_for('nbs_reports'))

def generate_order_number():
    prefix = "PB"
    timestamp = datetime.now().strftime("%Y%m%d")
    random_suffix = ''.join(random.choices(string.digits, k=4))
    return f"{prefix}{timestamp}{random_suffix}"

# ==================== PREBOOKING PRODUCTS CRUD ====================

@app.route('/prebooking-products')
def prebooking_products_list():
    if "user" not in session or session["user"]["role"] != "admin":
        return redirect("/login")

    user = session["user"]

    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    cursor.execute("SELECT * FROM prebooking_products ORDER BY product_name")
    products = cursor.fetchall()
    cursor.close()
    conn.close()

    return render_template('prebooking_products_list.html', user=user, products=products)


@app.route('/prebooking-products/add', methods=['POST'])
def add_prebooking_product():
    if "user" not in session or session["user"]["role"] != "admin":
        return jsonify({"success": False, "message": "Unauthorized"}), 403

    name = request.form['product_name'].strip()
    price = float(request.form['price'])
    status = request.form.get('status', 'active')

    if not name or price < 0:
        return jsonify({"success": False, "message": "Invalid data"}), 400

    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO prebooking_products (product_name, price, status)
            VALUES (%s, %s, %s)
        """, (name, price, status))
        conn.commit()
        return jsonify({"success": True, "message": "Product added successfully!"})
    except mysql.connector.IntegrityError:
        return jsonify({"success": False, "message": "Product name already exists!"})
    except Exception as e:
        conn.rollback()
        return jsonify({"success": False, "message": str(e)})
    finally:
        cursor.close()
        conn.close()


@app.route('/prebooking-products/update/<int:product_id>', methods=['POST'])
def update_prebooking_product(product_id):
    if "user" not in session or session["user"]["role"] != "admin":
        return jsonify({"success": False, "message": "Unauthorized"}), 403

    name = request.form['product_name'].strip()
    price = float(request.form['price'])
    status = request.form.get('status', 'active')

    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE prebooking_products 
            SET product_name = %s, price = %s, status = %s, updated_at = NOW()
            WHERE id = %s
        """, (name, price, status, product_id))
        conn.commit()
        return jsonify({"success": True, "message": "Product updated successfully!"})
    except mysql.connector.IntegrityError:
        return jsonify({"success": False, "message": "Product name already exists!"})
    except Exception as e:
        conn.rollback()
        return jsonify({"success": False, "message": str(e)})
    finally:
        cursor.close()
        conn.close()


@app.route('/prebooking-products/delete/<int:product_id>', methods=['POST'])
def delete_prebooking_product(product_id):
    if "user" not in session or session["user"]["role"] != "admin":
        return jsonify({"success": False, "message": "Unauthorized"}), 403

    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM prebooking_products WHERE id = %s", (product_id,))
        conn.commit()
        return jsonify({"success": True, "message": "Product deleted successfully!"})
    except Exception as e:
        conn.rollback()
        return jsonify({"success": False, "message": "Cannot delete: Product used in orders"})
    finally:
        cursor.close()
        conn.close()

# ==================== ADD PRE-BOOKING ====================
@app.route('/add-prebooking', methods=['GET', 'POST'])
def add_prebooking():
    if "user" not in session:
        return redirect("/login")
    
    user = session["user"]
    
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    
    # Fetch active products
    cursor.execute("SELECT id, product_name, price FROM prebooking_products WHERE status='active' ORDER BY product_name")
    products = cursor.fetchall()
    
    # Fetch restaurants for admin/store_manager
    restaurants = []
    if user['role'] in ['admin', 'store_manager']:
        cursor.execute("SELECT id, restaurantname FROM restaurant WHERE status='active' ORDER BY restaurantname")
        restaurants = cursor.fetchall()
    
    if request.method == 'POST':
        try:
            # Get form data
            username = request.form['username']
            mobile = request.form['mobile_number']
            email = request.form.get('email', '')
            address = request.form['delivery_address']
            delivery_date = request.form['delivery_date']
            delivery_time = request.form['delivery_time']
            amount_paid = float(request.form.get('amount_paid', 0))
            payment_method = request.form.get('payment_method', 'cash')  # New
            payment_remarks = request.form.get('payment_remarks', 'Initial payment').strip() or 'Initial payment'
            notes = request.form.get('notes', '')
            
            # Get discount values
            overall_discount = float(request.form.get('overall_discount', 0))
            
            # Get product items
            product_ids = request.form.getlist('product_id[]')
            quantities = request.form.getlist('quantity[]')
            product_discounts = request.form.getlist('product_discount[]')
            
            # Get restaurant_id
            restaurant_id = None
            if user['role'] in ['admin', 'store_manager']:
                restaurant_id = request.form.get('restaurant_id')
            elif user['role'] == 'branch_manager':
                # Map branch manager email to restaurant
                email_to_restaurant = {
                    "bmktcnagar@gmail.com": 1,
                    "bmnewbs@gmail.com": 2,
                    "dharanistorekeeper@gmail.com": 4
                }
                restaurant_id = email_to_restaurant.get(user.get('email'))
            
            # Validate products
            if not product_ids or not any(product_ids):
                flash("Please add at least one product!", "error")
                return redirect(url_for('add_prebooking'))
            
            # Calculate totals
            subtotal = 0
            product_discount_total = 0
            items_data = []
            
            for i, (product_id, quantity, product_discount) in enumerate(zip(product_ids, quantities, product_discounts)):
                if not product_id or not quantity or int(quantity) <= 0:
                    continue
                
                # Get product details
                cursor.execute("SELECT id, product_name, price FROM prebooking_products WHERE id=%s", (product_id,))
                product = cursor.fetchone()
                
                if product:
                    qty = int(quantity)
                    unit_price = float(product['price'])
                    item_discount = float(product_discount) if product_discount else 0
                    item_subtotal = unit_price * qty
                    item_final = item_subtotal - item_discount
                    
                    # Ensure amounts don't go negative
                    if item_final < 0:
                        item_final = 0
                    
                    subtotal += item_subtotal
                    product_discount_total += item_discount
                    
                    items_data.append({
                        'product_id': product_id,
                        'product_name': product['product_name'],
                        'unit_price': unit_price,
                        'quantity': qty,
                        'product_discount': item_discount,
                        'item_total': item_final
                    })
            
            if not items_data:
                flash("No valid products added!", "error")
                return redirect(url_for('add_prebooking'))
            
            # Calculate final amounts
            total_amount = subtotal - product_discount_total
            final_amount = total_amount - overall_discount
            
            # Ensure amounts don't go negative
            if final_amount < 0:
                final_amount = 0
            if total_amount < 0:
                total_amount = 0
            
            pending_balance = final_amount - amount_paid
            
            # Determine payment status
            if amount_paid == 0:
                payment_status = 'pending'
            elif amount_paid >= final_amount:
                payment_status = 'completed'
                pending_balance = 0
            else:
                payment_status = 'partial'
            
            # Generate order number
            order_number = generate_order_number()
            
            # Insert main order
            cursor.execute("""
                INSERT INTO prebooking_orders (
                    order_number, username, mobile_number, email, delivery_address,
                    subtotal, product_discount_total, overall_discount, total_amount,
                    final_amount, amount_paid, pending_balance, delivery_date, 
                    delivery_time, payment_status, restaurant_id, notes
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """, (
                order_number, username, mobile, email, address,
                subtotal, product_discount_total, overall_discount, total_amount,
                final_amount, amount_paid, pending_balance, delivery_date, 
                delivery_time, payment_status, restaurant_id, notes
            ))
            
            order_id = cursor.lastrowid
            
            # Insert order items
            for item in items_data:
                cursor.execute("""
                    INSERT INTO prebooking_order_items (
                        prebooking_order_id, product_id, product_name, unit_price,
                        quantity, product_discount, item_total
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                """, (
                    order_id, item['product_id'], item['product_name'],
                    item['unit_price'], item['quantity'], item['product_discount'],
                    item['item_total']
                ))
            
            # Record payment if amount paid > 0
            if amount_paid > 0:
                cursor.execute("""
                    INSERT INTO prebooking_payments (order_id, amount, payment_method, remarks, payment_date)
                    VALUES (%s, %s, %s, %s, NOW())
                """, (order_id, amount_paid, payment_method, payment_remarks))
            
            conn.commit()
            flash(f"Pre-booking created successfully! Order Number: {order_number}", "success")
            return redirect(url_for('prebooking_list'))
            
        except Exception as e:
            conn.rollback()
            flash(f"Error: {str(e)}", "error")
        finally:
            cursor.close()
            conn.close()
    
    return render_template('add_prebooking.html', user=user, products=products, restaurants=restaurants, today=date.today())


# ==================== PREBOOKING LIST ====================
@app.route('/prebooking-list', methods=['GET'])
def prebooking_list():
    if "user" not in session:
        return redirect("/login")
    
    user = session["user"]
    role = user["role"]
    email = user.get("email")
    
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    
    # ---------- 1. BRANCH SELECTION (admin only) ----------
    branch_id = request.args.get("branch_id")
    branches = []
    if role == 'admin':
        cursor.execute("SELECT id, restaurantname FROM restaurant ORDER BY restaurantname")
        branches = cursor.fetchall()

    # ---------- 2. Pagination ----------
    per_page = 10
    page = int(request.args.get("page", 1))
    offset = (page - 1) * per_page
    
    # ---------- 3. Filters ----------
    search = request.args.get("search", "")
    status_filter = request.args.get("status", "")
    payment_filter = request.args.get("payment", "")
    start_date = request.args.get("start_date", "")
    end_date = request.args.get("end_date", "")
    product_filter = request.args.get("product_id", "")  # NEW: Product filter

    # Fetch all active products for dropdown
    cursor.execute("SELECT id, product_name FROM prebooking_products WHERE status='active' ORDER BY product_name")
    products = cursor.fetchall()

    # ---------- 4. Base query ----------
    base_query = """
        FROM prebooking_orders po
        LEFT JOIN restaurant r ON po.restaurant_id = r.id
        LEFT JOIN prebooking_order_items poi ON po.id = poi.prebooking_order_id
        WHERE po.is_deleted = 0
    """
    params = []
    
    # Role + Branch filter
    if role == 'branch_manager':
        email_to_restaurant = {
            "bmktcnagar@gmail.com": 1,
            "bmnewbs@gmail.com": 2,
            "dharanistorekeeper@gmail.com": 4
        }
        restaurant_id = email_to_restaurant.get(email)
        if restaurant_id:
            base_query += " AND po.restaurant_id = %s"
            params.append(restaurant_id)
    elif role == 'admin' and branch_id:
        base_query += " AND po.restaurant_id = %s"
        params.append(branch_id)

    # Search filter
    if search:
        base_query += " AND (po.order_number LIKE %s OR po.username LIKE %s OR po.mobile_number LIKE %s)"
        s = f"%{search}%"
        params.extend([s, s, s])

    # Other filters
    if status_filter:
        base_query += " AND po.order_status = %s"
        params.append(status_filter)
    if payment_filter:
        base_query += " AND po.payment_status = %s"
        params.append(payment_filter)
    if start_date and end_date:
        base_query += " AND po.delivery_date BETWEEN %s AND %s"
        params.extend([start_date, end_date])
    elif start_date:
        base_query += " AND po.delivery_date >= %s"
        params.append(start_date)
    elif end_date:
        base_query += " AND po.delivery_date <= %s"
        params.append(end_date)

    # NEW: Product Filter - Match any item in order
    if product_filter:
        base_query += " AND poi.product_id = %s"
        params.append(product_filter)

    # ---------- 5. Summary totals ----------
    summary_query = f"""
        SELECT 
            COALESCE(SUM(po.final_amount), 0)        AS total_prebooked,
            COALESCE(SUM(po.amount_paid), 0)         AS total_paid,
            COALESCE(SUM(po.pending_balance), 0)     AS total_pending
        {base_query}
    """
    cursor.execute(summary_query, params)
    summary = cursor.fetchone()

    # ---------- 6. Total rows ----------
    count_query = f"SELECT COUNT(DISTINCT po.id) as total {base_query}"
    cursor.execute(count_query, params)
    total_records = cursor.fetchone()["total"]
    total_pages = (total_records + per_page - 1) // per_page

    # ---------- 7. Fetch orders with DISTINCT to avoid duplicates ----------
    orders_query = f"""
        SELECT DISTINCT po.*, r.restaurantname
        {base_query}
        GROUP BY po.id
        ORDER BY po.created_at DESC
        LIMIT %s OFFSET %s
    """
    cursor.execute(orders_query, (*params, per_page, offset))
    orders = cursor.fetchall()

    # Attach product names to each order
    for order in orders:
        cursor.execute("""
            SELECT product_name, quantity 
            FROM prebooking_order_items 
            WHERE prebooking_order_id = %s
        """, (order['id'],))
        items = cursor.fetchall()
        product_names = [f"{item['product_name']} ({item['quantity']})" for item in items] if items else ["No products"]
        order['product_names'] = ", ".join(product_names)

    cursor.close()
    conn.close()

    return render_template(
        'prebooking_list.html',
        user=user,
        orders=orders,
        summary=summary,
        branches=branches,
        products=products,                    # Pass products to template
        selected_branch=branch_id or "",
        selected_product=product_filter or "", # Preserve selected product
        page=page,
        total_pages=total_pages,
        search=search,
        status_filter=status_filter,
        payment_filter=payment_filter,
        start_date=start_date,
        end_date=end_date,
        datetime=datetime
    )


# ==================== VIEW PREBOOKING ====================
@app.route('/view-prebooking/<int:order_id>')
def view_prebooking(order_id):
    if "user" not in session:
        return redirect("/login")
    
    user = session["user"]
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    
    # Fetch order details
    cursor.execute("""
        SELECT po.*, r.restaurantname
        FROM prebooking_orders po
        LEFT JOIN restaurant r ON po.restaurant_id = r.id
        WHERE po.id = %s AND po.is_deleted = 0
    """, (order_id,))
    order = cursor.fetchone()
    
    if not order:
        flash("Order not found!", "error")
        return redirect(url_for('prebooking_list'))
    
    # Fetch order items
    cursor.execute("""
        SELECT poi.* 
        FROM prebooking_order_items poi
        WHERE poi.prebooking_order_id = %s
        ORDER BY poi.id
    """, (order_id,))
    order_items = cursor.fetchall()
    
    # Fetch payment history
    cursor.execute("""
        SELECT * FROM prebooking_payments
        WHERE order_id = %s
        ORDER BY payment_date DESC
    """, (order_id,))
    payments = cursor.fetchall()
    
    cursor.close()
    conn.close()
    
    return render_template(
        'view_prebooking.html',
        user=user,
        order=order,
        order_items=order_items,
        payments=payments,
        datetime=datetime
    )

# ==================== EDIT PREBOOKING ====================
@app.route('/edit-prebooking/<int:order_id>', methods=['GET', 'POST'])
def edit_prebooking(order_id):
    if "user" not in session or session["user"]["role"] != 'admin':
        return redirect("/login")

    user = session["user"]
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    if request.method == 'GET':
        # Fetch order details
        cursor.execute("""
            SELECT po.*, r.restaurantname
            FROM prebooking_orders po
            LEFT JOIN restaurant r ON po.restaurant_id = r.id
            WHERE po.id = %s AND po.is_deleted = 0
        """, (order_id,))
        order = cursor.fetchone()

        if not order:
            flash("Order not found!", "error")
            return redirect(url_for('prebooking_list'))

        # Fetch order items
        cursor.execute("""
            SELECT poi.*
            FROM prebooking_order_items poi
            WHERE poi.prebooking_order_id = %s
        """, (order_id,))
        order_items = cursor.fetchall()

        cursor.execute("SELECT id, product_name, price FROM prebooking_products ORDER BY product_name")
        products = cursor.fetchall()

        cursor.execute("SELECT id, restaurantname FROM restaurant ORDER BY restaurantname")
        restaurants = cursor.fetchall()

        cursor.close()
        conn.close()

        return render_template(
            'edit_prebooking.html',
            order=order,
            order_items=order_items,
            user=user,
            products=products,
            restaurants=restaurants,
            today=date.today().isoformat(),
            datetime=datetime
        )

    elif request.method == 'POST':
        try:
            # === Fetch current order to compare amount_paid ===
            cursor.execute("SELECT amount_paid FROM prebooking_orders WHERE id = %s", (order_id,))
            current = cursor.fetchone()
            if not current:
                flash("Order not found!", "error")
                return redirect(url_for('prebooking_list'))

            old_amount_paid = float(current['amount_paid'])
            new_amount_paid = float(request.form.get('amount_paid', 0))
            payment_method = request.form.get('payment_method', 'cash')
            payment_remarks = request.form.get('payment_remarks', '').strip()
            if not payment_remarks:
                payment_remarks = 'Payment adjusted on edit'

            # === Extract other form data ===
            username = request.form['username']
            mobile_number = request.form['mobile_number']
            email = request.form.get('email', '')
            delivery_address = request.form['delivery_address']
            delivery_date = request.form['delivery_date']
            delivery_time = request.form['delivery_time']
            notes = request.form.get('notes', '')
            restaurant_id = request.form['restaurant_id']
            overall_discount = float(request.form.get('overall_discount', 0))

            # === Product items ===
            product_ids = request.form.getlist('product_id[]')
            quantities = request.form.getlist('quantity[]')
            product_discounts = request.form.getlist('product_discount[]')

            # === Recalculate totals ===
            subtotal = 0
            product_discount_total = 0
            items_data = []

            for product_id, quantity, product_discount in zip(product_ids, quantities, product_discounts):
                if not product_id or not quantity or int(quantity) <= 0:
                    continue

                cursor.execute("SELECT id, product_name, price FROM prebooking_products WHERE id=%s", (product_id,))
                product = cursor.fetchone()
                if not product:
                    continue

                qty = int(quantity)
                unit_price = float(product['price'])
                item_discount = float(product_discount) if product_discount else 0
                item_subtotal = unit_price * qty
                item_total = max(0, item_subtotal - item_discount)

                subtotal += item_subtotal
                product_discount_total += item_discount

                items_data.append({
                    'product_id': product_id,
                    'product_name': product['product_name'],
                    'unit_price': unit_price,
                    'quantity': qty,
                    'product_discount': item_discount,
                    'item_total': item_total
                })

            if not items_data:
                flash("Please add at least one product!", "error")
                return redirect(url_for('edit_prebooking', order_id=order_id))

            total_amount = max(0, subtotal - product_discount_total)
            final_amount = max(0, total_amount - overall_discount)
            pending_balance = max(0, final_amount - new_amount_paid)

            # Determine payment status
            if pending_balance <= 0:
                payment_status = 'completed'
            elif new_amount_paid > 0:
                payment_status = 'partial'
            else:
                payment_status = 'pending'

            # === Update main order ===
            cursor.execute("""
                UPDATE prebooking_orders SET
                    username = %s, mobile_number = %s, email = %s,
                    delivery_address = %s, subtotal = %s, product_discount_total = %s,
                    overall_discount = %s, total_amount = %s, final_amount = %s,
                    amount_paid = %s, pending_balance = %s, payment_status = %s,
                    delivery_date = %s, delivery_time = %s, notes = %s,
                    restaurant_id = %s
                WHERE id = %s
            """, (
                username, mobile_number, email, delivery_address,
                subtotal, product_discount_total, overall_discount,
                total_amount, final_amount, new_amount_paid, pending_balance,
                payment_status, delivery_date, delivery_time, notes,
                restaurant_id, order_id
            ))

            # === Replace order items ===
            cursor.execute("DELETE FROM prebooking_order_items WHERE prebooking_order_id = %s", (order_id,))
            for item in items_data:
                cursor.execute("""
                    INSERT INTO prebooking_order_items (
                        prebooking_order_id, product_id, product_name, unit_price,
                        quantity, product_discount, item_total
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                """, (
                    order_id, item['product_id'], item['product_name'],
                    item['unit_price'], item['quantity'], item['product_discount'],
                    item['item_total']
                ))

            # === Record additional payment only if increased ===
            if new_amount_paid > old_amount_paid:
                additional_amount = new_amount_paid - old_amount_paid
                cursor.execute("""
                    INSERT INTO prebooking_payments 
                    (order_id, amount, payment_method, remarks, payment_date)
                    VALUES (%s, %s, %s, %s, NOW())
                """, (order_id, additional_amount, payment_method, payment_remarks))

            # === If amount_paid decreased (rare case), you may want to log or warn ===
            elif new_amount_paid < old_amount_paid:
                # Optional: Log this as a refund or adjustment
                reduction = old_amount_paid - new_amount_paid
                cursor.execute("""
                    INSERT INTO prebooking_payments 
                    (order_id, amount, payment_method, remarks, payment_date)
                    VALUES (%s, %s, %s, %s, NOW())
                """, (order_id, -reduction, 'adjustment', f"Amount reduced by admin (edit): {payment_remarks}"))

            conn.commit()
            flash("Pre-booking updated successfully!", "success")

        except Exception as e:
            conn.rollback()
            flash(f"Error updating order: {str(e)}", "error")
        finally:
            cursor.close()
            conn.close()

        return redirect(url_for('prebooking_list'))

# ==================== DELETE PREBOOKING ====================
@app.route('/delete-prebooking/<int:order_id>', methods=['POST'])
def delete_prebooking(order_id):
    if "user" not in session or session["user"]["role"] != 'admin':
        return redirect("/login")

    conn = get_db_connection()
    cursor = conn.cursor()

    try:
        cursor.execute("""
            UPDATE prebooking_orders 
            SET is_deleted = 1 
            WHERE id = %s AND is_deleted = 0
        """, (order_id,))
        
        if cursor.rowcount > 0:
            flash("Pre-booking deleted successfully!", "success")
        else:
            flash("Order not found or already deleted.", "error")
            
        conn.commit()
    except Exception as e:
        conn.rollback()
        flash(f"Error deleting order: {str(e)}", "error")
    finally:
        cursor.close()
        conn.close()

    return redirect(url_for('prebooking_list'))

# ==================== ADD PAYMENT ====================
@app.route('/add-payment/<int:order_id>', methods=['POST'])
def add_payment(order_id):
    if "user" not in session:
        return redirect("/login")
    
    try:
        amount = float(request.form['amount'])
        payment_method = request.form.get('payment_method', 'cash')
        remarks = request.form.get('remarks', '')
        
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)
        
        # Get current order
        cursor.execute("SELECT * FROM prebooking_orders WHERE id=%s", (order_id,))
        order = cursor.fetchone()
        
        if not order:
            flash("Order not found!", "error")
            return redirect(url_for('prebooking_list'))
        
        # Calculate new pending balance (using final_amount instead of total_amount)
        new_amount_paid = float(order['amount_paid']) + amount
        new_pending = float(order['final_amount']) - new_amount_paid
        
        # Determine payment status
        if new_pending <= 0:
            payment_status = 'completed'
            new_pending = 0
        elif new_amount_paid > 0:
            payment_status = 'partial'
        else:
            payment_status = 'pending'
        
        # Update order
        cursor.execute("""
            UPDATE prebooking_orders
            SET amount_paid = %s, pending_balance = %s, payment_status = %s
            WHERE id = %s
        """, (new_amount_paid, new_pending, payment_status, order_id))
        
        # Record payment
        cursor.execute("""
            INSERT INTO prebooking_payments (order_id, amount, payment_method, remarks)
            VALUES (%s, %s, %s, %s)
        """, (order_id, amount, payment_method, remarks))
        
        conn.commit()
        flash("Payment added successfully!", "success")
        
    except Exception as e:
        conn.rollback()
        flash(f"Error: {str(e)}", "error")
    finally:
        cursor.close()
        conn.close()
    
    return redirect(url_for('view_prebooking', order_id=order_id))


# ==================== UPDATE ORDER STATUS ====================
@app.route('/update-order-status/<int:order_id>', methods=['POST'])
def update_order_status(order_id):
    if "user" not in session or session["user"]["role"] not in ['admin', 'store_manager', 'branch_manager']:
        return redirect("/login")
    
    try:
        new_status = request.form['order_status']
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE prebooking_orders
            SET order_status = %s
            WHERE id = %s
        """, (new_status, order_id))
        
        conn.commit()
        flash("Order status updated successfully!", "success")
        
    except Exception as e:
        conn.rollback()
        flash(f"Error: {str(e)}", "error")
    finally:
        cursor.close()
        conn.close()
    
    return redirect(url_for('view_prebooking', order_id=order_id))


# ==================== GET PRODUCT PRICE (AJAX) ====================
@app.route('/get-product-price/<int:product_id>')
def get_product_price(product_id):
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    
    cursor.execute("SELECT price FROM prebooking_products WHERE id=%s", (product_id,))
    product = cursor.fetchone()
    
    cursor.close()
    conn.close()
    
    if product:
        return jsonify({'price': float(product['price'])})
    return jsonify({'price': 0})

if __name__ == "__main__":
    app.run()
